{"0":"<code class=\"docstring\">`namespace &lt;id&gt;` opens a section with label `&lt;id&gt;` that influences naming and name resolution inside\nthe section:\n* Declarations names are prefixed: `def seventeen : ℕ := 17` inside a namespace `Nat` is given the\n  full name `Nat.seventeen`.\n* Names introduced by `export` declarations are also prefixed by the identifier.\n* All names starting with `&lt;id&gt;.` become available in the namespace without the prefix. These names\n  are preferred over names introduced by outer namespaces or `open`.\n* Within a namespace, declarations can be `protected`, which excludes them from the effects of\n  opening the namespace.\n\nAs with `section`, namespaces can be nested and the scope of a namespace is terminated by a\ncorresponding `end &lt;id&gt;` or the end of the file.\n\n`namespace` also acts like `section` in delimiting the scope of `variable`, `open`, and other scoped commands.\n</code>","1":"<code class=\"docstring\">The universe of propositions. `Prop ≡ Sort 0`.\n\nEvery proposition is propositionally equal to either `True` or `False`. </code>","10":"<code>LeanW26.Universes.f2.{w} (x : Type w) : Type w</code>","100":"<code>LeanW26.Monads.Maybe.none.{u} {α : Type u} : Maybe α</code>","101":"<code>LeanW26.Monads.Maybe.some.{u} {α : Type u} : α → Maybe α</code>","102":"<code class=\"docstring\">Makes names from other namespaces visible without writing the namespace prefix.\n\nNames that are made available with `open` are visible within the current `section` or `namespace`\nblock. This makes referring to (type) definitions and theorems easier, but note that it can also\nmake [scoped instances], notations, and attributes from a different namespace available.\n\nThe `open` command can be used in a few different ways:\n\n* `open Some.Namespace.Path1 Some.Namespace.Path2` makes all non-protected names in\n  `Some.Namespace.Path1` and `Some.Namespace.Path2` available without the prefix, so that\n  `Some.Namespace.Path1.x` and `Some.Namespace.Path2.y` can be referred to by writing only `x` and\n  `y`.\n\n* `open Some.Namespace.Path hiding def1 def2` opens all non-protected names in `Some.Namespace.Path`\n  except `def1` and `def2`.\n\n* `open Some.Namespace.Path (def1 def2)` only makes `Some.Namespace.Path.def1` and\n  `Some.Namespace.Path.def2` available without the full prefix, so `Some.Namespace.Path.def3` would\n  be unaffected.\n\n  This works even if `def1` and `def2` are `protected`.\n\n* `open Some.Namespace.Path renaming def1 → def1', def2 → def2'` same as `open Some.Namespace.Path\n  (def1 def2)` but `def1`/`def2`'s names are changed to `def1'`/`def2'`.\n\n  This works even if `def1` and `def2` are `protected`.\n\n* `open scoped Some.Namespace.Path1 Some.Namespace.Path2` **only** opens [scoped instances],\n  notations, and attributes from `Namespace1` and `Namespace2`; it does **not** make any other name\n  available.\n\n* `open &lt;any of the open shapes above&gt; in` makes the names `open`-ed visible only in the next\n  command or expression.\n\n[scoped instance]: https://lean-lang.org/theorem_proving_in_lean4/type_classes.html#scoped-instances\n(Scoped instances in Theorem Proving in Lean)\n\n\n## Examples\n\n```lean\n/-- SKI combinators https://en.wikipedia.org/wiki/SKI_combinator_calculus -/\nnamespace Combinator.Calculus\n  def I (a : α) : α := a\n  def K (a : α) : β → α := fun _ =&gt; a\n  def S (x : α → β → γ) (y : α → β) (z : α) : γ := x z (y z)\nend Combinator.Calculus\n\nsection\n  -- open everything under `Combinator.Calculus`, *i.e.* `I`, `K` and `S`,\n  -- until the section ends\n  open Combinator.Calculus\n\n  theorem SKx_eq_K : S K x = I := rfl\nend\n\n-- open everything under `Combinator.Calculus` only for the next command (the next `theorem`, here)\nopen Combinator.Calculus in\ntheorem SKx_eq_K' : S K x = I := rfl\n\nsection\n  -- open only `S` and `K` under `Combinator.Calculus`\n  open Combinator.Calculus (S K)\n\n  theorem SKxy_eq_y : S K x y = y := rfl\n\n  -- `I` is not in scope, we have to use its full path\n  theorem SKxy_eq_Iy : S K x y = Combinator.Calculus.I y := rfl\nend\n\nsection\n  open Combinator.Calculus\n    renaming\n      I → identity,\n      K → konstant\n\n  #check identity\n  #check konstant\nend\n\nsection\n  open Combinator.Calculus\n    hiding S\n\n  #check I\n  #check K\nend\n\nsection\n  namespace Demo\n    inductive MyType\n    | val\n\n    namespace N1\n      scoped infix:68 \" ≋ \" =&gt; BEq.beq\n\n      scoped instance : BEq MyType where\n        beq _ _ := true\n\n      def Alias := MyType\n    end N1\n  end Demo\n\n  -- bring `≋` and the instance in scope, but not `Alias`\n  open scoped Demo.N1\n\n  #check Demo.MyType.val == Demo.MyType.val\n  #check Demo.MyType.val ≋ Demo.MyType.val\n  -- #check Alias -- unknown identifier 'Alias'\nend\n```\n</code>","103":"<code>LeanW26.Monads.first.{u} {α : Type u} (L : List α) : Maybe α</code>","104":"<code>List α</code>","105":"<code>LeanW26.Monads.first_char (s : String) : Maybe Char</code>","106":"<code>String</code>","107":"<code>Char : Type</code><span class=\"sep\"></span><code class=\"docstring\">Characters are Unicode [scalar values](http://www.unicode.org/glossary/#unicode_scalar_value).\n</code>","108":"<code class=\"docstring\">\"Dependent\" if-then-else, normally written via the notation `if h : c then t(h) else e(h)`,\nis sugar for `dite c (fun h =&gt; t(h)) (fun h =&gt; e(h))`, and it is the same as\n`if c then t else e` except that `t` is allowed to depend on a proof `h : c`,\nand `e` can depend on `h : ¬c`. (Both branches use the same name for the hypothesis,\neven though it has different types in the two cases.)\n\nWe use this to be able to communicate the if-then-else condition to the branches.\nFor example, `Array.get arr i h` expects a proof `h : i &lt; arr.size` in order to\navoid a bounds check, so you can write `if h : i &lt; arr.size then arr.get i h else ...`\nto avoid the bounds check inside the if branch. (Of course in this case we have only\nlifted the check into an explicit `if`, but we could also use this proof multiple times\nor derive `i &lt; arr.size` from some other proposition that we are checking in the `if`.)\n</code>","109":"<code>s.length &gt; 0</code>","11":"<code>Type w</code>","110":"<code>String.length (b : String) : ℕ</code><span class=\"sep\"></span><code class=\"docstring\">Returns the length of a string in Unicode code points.\n\nExamples:\n* `\"\".length = 0`\n* `\"abc\".length = 3`\n* `\"L∃∀N\".length = 4`\n</code>","111":"<code>String.data (b : String) : List Char</code><span class=\"sep\"></span><code class=\"docstring\">Converts a string to a list of characters.\n\nSince strings are represented as dynamic arrays of bytes containing the string encoded using\nUTF-8, this operation takes time and space linear in the length of the string.\n\nExamples:\n * `\"abc\".toList = ['a', 'b', 'c']`\n * `\"\".toList = []`\n * `\"\\n\".toList = ['\\n']`\n</code>","112":"<code>String.toList (s : String) : List Char</code><span class=\"sep\"></span><code class=\"docstring\">Converts a string to a list of characters.\n\nSince strings are represented as dynamic arrays of bytes containing the string encoded using\nUTF-8, this operation takes time and space linear in the length of the string.\n\nExamples:\n * `\"abc\".toList = ['a', 'b', 'c']`\n * `\"\".toList = []`\n * `\"\\n\".toList = ['\\n']`\n</code>","113":"<code><span class=\"literal string\">\"Romeo, Romeo, wherefore art thou Romeo?\"</span> : String</code>","114":"<code>LeanW26.Monads.Oops.{u} (α : Type u) : Type u</code>","115":"<code>LeanW26.Monads.Oops.except.{u} {α : Type u} : String → Oops α</code>","116":"<code>LeanW26.Monads.Oops.ok.{u} {α : Type u} : α → Oops α</code>","117":"<code>LeanW26.Monads.first'.{u} {α : Type u} (L : List α) : Oops α</code>","118":"<code><span class=\"literal string\">\"Tried to get the first value of an empty list\"</span> : String</code>","119":"<code>LeanW26.Monads.first_two'.{v} {α : Type v} (L : List α) : Maybe (List α)</code>","12":"<code class=\"docstring\">The universe parameter w</code>","120":"<code>LeanW26.Monads.andThen.{v, w} {α : Type v} {β : Type w} (maybe : Maybe α) (next : α → Maybe β) : Maybe β</code>","121":"<code>Maybe α</code>","122":"<code>α → Maybe β</code>","123":"<code>LeanW26.Monads.first_two.{v} {α : Type v} (L : List α) : Maybe (List α)</code>","124":"<code>List.tail.{u} {α : Type u} : List α → List α</code><span class=\"sep\"></span><code class=\"docstring\">Drops the first element of a nonempty list, returning the tail. Returns `[]` when the argument is\nempty.\n\nExamples:\n * `[\"apple\", \"banana\", \"grape\"].tail = [\"banana\", \"grape\"]`\n * `[\"apple\"].tail = []`\n * `([] : List String).tail = []`\n</code>","125":"<code class=\"docstring\">`infixl:prec \"op\" =&gt; f` is equivalent to `notation:prec x:prec \"op\" y:prec1 =&gt; f x y`, where `prec1 := prec + 1`.\n</code>","126":"<code><span class=\"literal string\">\" ~~&gt; \"</span> : String</code>","127":"<code>LeanW26.Monads.first_two''.{v} {α : Type v} (L : List α) : Maybe (List α)</code>","128":"<code>Monad.{u, v} (m : Type u → Type v) : Type (max (u + 1) v)</code><span class=\"sep\"></span><code class=\"docstring\">[Monads](https://en.wikipedia.org/wiki/Monad_(functional_programming)) are an abstraction of\nsequential control flow and side effects used in functional programming. Monads allow both\nsequencing of effects and data-dependent effects: the values that result from an early step may\ninfluence the effects carried out in a later step.\n\nThe `Monad` API may be used directly. However, it is most commonly accessed through\n[`do`-notation](https://lean-lang.org/doc/reference/4.26.0-rc2/find/?domain=Verso.Genre.Manual.section&name=do-notation).\n\nMost `Monad` instances provide implementations of `pure` and `bind`, and use default implementations\nfor the other methods inherited from `Applicative`. Monads should satisfy certain laws, but\ninstances are not required to prove this. An instance of `LawfulMonad` expresses that a given\nmonad's operations are lawful.\n</code>","129":"<code>{α : Type u_1} → α → Maybe α</code><span class=\"sep\"></span><code class=\"docstring\">Given `a : α`, then `pure a : f α` represents an action that does nothing and returns `a`.\n\nExamples:\n* `(pure \"hello\" : Option String) = some \"hello\"`\n* `(pure \"hello\" : Except (Array String) String) = Except.ok \"hello\"`\n* `(pure \"hello\" : StateM Nat String).run 105 = (\"hello\", 105)`\n</code>","13":"<code>Nat : Type</code><span class=\"sep\"></span><code class=\"docstring\">The natural numbers, starting at zero.\n\nThis type is special-cased by both the kernel and the compiler, and overridden with an efficient\nimplementation. Both use a fast arbitrary-precision arithmetic library (usually\n[GMP](https://gmplib.org/)); at runtime, `Nat` values that are sufficiently small are unboxed.\n</code>","130":"<code>{α β : Type u_1} → Maybe α → (α → Maybe β) → Maybe β</code><span class=\"sep\"></span><code class=\"docstring\">Sequences two computations, allowing the second to depend on the value computed by the first.\n\nIf `x : m α` and `f : α → m β`, then `x &gt;&gt;= f : m β` represents the result of executing `x` to get\na value of type `α` and then passing it to `f`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `&gt;&gt;=` in identifiers is `bind`.</code>","131":"<code>Maybe α✝</code>","132":"<code>α✝ → Maybe β✝</code>","133":"<code>LeanW26.Monads.first_two_m.{v} {α : Type v} (L : List α) : Maybe (List α)</code>","134":"<code>LeanW26.Monads.first_two_do.{v} {α : Type v} (L : List α) : Maybe (List α)</code>","135":"<code>LeanW26.Monads.doubleM (m : Type → Type) [Monad m] (x : ℕ) : m ℕ</code>","136":"<code>Pure.pure.{u, v} {f : Type u → Type v} [self : Pure f] {α : Type u} : α → f α</code><span class=\"sep\"></span><code class=\"docstring\">Given `a : α`, then `pure a : f α` represents an action that does nothing and returns `a`.\n\nExamples:\n* `(pure \"hello\" : Option String) = some \"hello\"`\n* `(pure \"hello\" : Except (Array String) String) = Except.ok \"hello\"`\n* `(pure \"hello\" : StateM Nat String).run 105 = (\"hello\", 105)`\n</code>","137":"<code>Option.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">Optional values, which are either `some` around a value from the underlying type or `none`.\n\n`Option` can represent nullable types or computations that might fail. In the codomain of a function\ntype, it can also represent partiality.\n</code>","138":"<code>Except.{u, v} (ε : Type u) (α : Type v) : Type (max u v)</code><span class=\"sep\"></span><code class=\"docstring\">`Except ε α` is a type which represents either an error of type `ε` or a successful result with a\nvalue of type `α`.\n\n`Except ε : Type u → Type v` is a `Monad` that represents computations that may throw exceptions:\nthe `pure` operation is `Except.ok` and the `bind` operation returns the first encountered\n`Except.error`.\n</code>","139":"<code>Id.{u} (type : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">The identity function on types, used primarily for its `Monad` instance.\n\nThe identity monad is useful together with monad transformers to construct monads for particular\npurposes. Additionally, it can be used with `do`-notation in order to use control structures such as\nlocal mutability, `for`-loops, and early returns in code that does not otherwise use monads.\n\nExamples:\n```lean example\ndef containsFive (xs : List Nat) : Bool := Id.run do\n  for x in xs do\n    if x == 5 then return true\n  return false\n```\n\n```lean example\n#eval containsFive [1, 3, 5, 7]\n```\n```output\ntrue\n```\n</code>","14":"<code>List.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">Linked lists: ordered lists, in which each element has a reference to the next element.\n\nMost operations on linked lists take time proportional to the length of the list, because each\nelement must be traversed to find the next element.\n\n`List α` is isomorphic to `Array α`, but they are useful for different things:\n* `List α` is easier for reasoning, and `Array α` is modeled as a wrapper around `List α`.\n* `List α` works well as a persistent data structure, when many copies of the tail are shared. When\n  the value is not shared, `Array α` will have better performance because it can do destructive\n  updates.\n</code>","140":"<code>LeanW26.Monads.main : IO Unit</code>","141":"<code>IO : Type → Type</code><span class=\"sep\"></span><code class=\"docstring\">A monad that supports arbitrary side effects and throwing exceptions of type `IO.Error`.\n</code>","142":"<code>Unit : Type</code><span class=\"sep\"></span><code class=\"docstring\">The canonical type with one element. This element is written `()`.\n\n`Unit` has a number of uses:\n* It can be used to model control flow that returns from a function call without providing other\n  information.\n* Monadic actions that return `Unit` have side effects without computing values.\n* In polymorphic types, it can be used to indicate that no data is to be stored in a particular\n  field.\n</code>","143":"<code>IO.println.{u_1} {α : Type u_1} [ToString α] (s : α) : IO Unit</code><span class=\"sep\"></span><code class=\"docstring\">Converts `s` to a string using its `ToString α` instance, and prints it with a trailing newline to\nthe current standard output (as determined by `IO.getStdout`).\n</code>","144":"<code><span class=\"literal string\">\"Hello!\"</span> : String</code>","145":"<code><span class=\"literal string\">\"This is the IO Monad\"</span> : String</code>","146":"<code><span class=\"literal string\">\"If you run this code from the command line\"</span> : String</code>","147":"<code><span class=\"literal string\">\"you can use IO.getLine\"</span> : String</code>","148":"<code><span class=\"literal string\">\"You can examime the filesystem too.\"</span> : String</code>","149":"<code>System.FilePath</code>","15":"<code>LeanW26.Universes.my_id.{u} (x : Type u) : Type u</code>","150":"<code>IO.currentDir : IO System.FilePath</code><span class=\"sep\"></span><code class=\"docstring\">Returns the current working directory of the executing process.\n</code>","151":"<code>LeanW26.Monads.pairs : List (ℕ × ℕ)</code>","152":"<code>LeanW26.Monads.prods : List ℕ</code>","153":"<code>LeanW26.f1 (x : ℕ) : ℕ</code>","154":"<code>LeanW26.f2 (x : ℕ) : ℕ</code>","155":"<code class=\"docstring\">`if c then t else e` is notation for `ite c t e`, \"if-then-else\", which decides to\nreturn `t` or `e` depending on whether `c` is true or false. The explicit argument\n`c : Prop` does not have any actual computational content, but there is an additional\n`[Decidable c]` argument synthesized by typeclass inference which actually\ndetermines how to evaluate `c` to true or false. Write `if h : c then t else e`\ninstead for a \"dependent if-then-else\" `dite`, which allows `t`/`e` to use the fact\nthat `c` is true/false.\n</code>","156":"<code>Even.{u_2} {α : Type u_2} [Add α] (a : α) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">An element `a` of a type `α` with addition satisfies `Even a` if `a = r + r`,\nfor some `r : α`. </code>","157":"<code>LeanW26.f3 (x : ℕ) : ℕ</code>","158":"<code>LeanW26.do_twice (f : ℕ → ℕ) (x : ℕ) : ℕ</code>","159":"<code>ℕ → ℕ</code>","16":"<code>String : Type</code><span class=\"sep\"></span><code class=\"docstring\">A string is a sequence of Unicode scalar values.\n\nAt runtime, strings are represented by [dynamic arrays](https://en.wikipedia.org/wiki/Dynamic_array)\nof bytes using the UTF-8 encoding. Both the size in bytes (`String.utf8ByteSize`) and in characters\n(`String.length`) are cached and take constant time. Many operations on strings perform in-place\nmodifications when the reference to the string is unique.\n</code>","160":"<code>LeanW26.h1 (x : ℕ) : ℕ</code>","161":"<code>LeanW26.h2 : ℕ → ℕ</code>","162":"<code>LeanW26.h3 : ℕ → ℕ</code>","163":"<code>LeanW26.nonzero (x : ℕ) : Bool</code>","164":"<code>Nat.zero : ℕ</code><span class=\"sep\"></span><code class=\"docstring\">Zero, the smallest natural number.\n\nUsing `Nat.zero` explicitly should usually be avoided in favor of the literal `0`, which is the\n[simp normal form](https://lean-lang.org/doc/reference/4.26.0-rc2/find/?domain=Verso.Genre.Manual.section&name=simp-normal-forms).\n</code>","165":"<code>Nat.succ (n : ℕ) : ℕ</code><span class=\"sep\"></span><code class=\"docstring\">The successor of a natural number `n`.\n\nUsing `Nat.succ n` should usually be avoided in favor of `n + 1`, which is the [simp normal\nform](https://lean-lang.org/doc/reference/4.26.0-rc2/find/?domain=Verso.Genre.Manual.section&name=simp-normal-forms).\n</code>","166":"<code>LeanW26.nonzero' (x : ℕ) : Prop</code>","167":"<code>LeanW26.is_3_or_12 (x : ℕ) : Bool</code>","168":"<code>LeanW26.is_3_and_12 (x y : ℕ) : Bool</code>","169":"<code>LeanW26.fct (n : ℕ) : ℕ</code>","17":"<code class=\"docstring\">The universe level 1</code>","170":"<code>LeanW26.do_n (n : ℕ) (f : ℕ → ℕ) (x : ℕ) : ℕ</code>","171":"<code>LeanW26.f10 (x : ℕ) : ℕ</code>","172":"<code>LeanW26.factAux (n acc : ℕ) : ℕ</code>","173":"<code>LeanW26.fact (n : ℕ) : ℕ</code>","174":"<code>LeanW26.fact2 (n : ℕ) : ℕ</code>","175":"<code>LeanW26.fact2.aux (n acc : ℕ) : ℕ</code>","176":"<code>LeanW26.helper (n acc : ℕ) : factAux n acc = acc * fct n</code>","177":"<code class=\"docstring\">`by tac` constructs a term of the expected type by running the tactic(s) `tac`. </code>","178":"<code>Eq.{u_1} {α : Sort u_1} : α → α → Prop</code><span class=\"sep\"></span><code class=\"docstring\">The equality relation. It has one introduction rule, `Eq.refl`.\nWe use `a = b` as notation for `Eq a b`.\nA fundamental property of equality is that it is an equivalence relation.\n```\nvariable (α : Type) (a b c d : α)\nvariable (hab : a = b) (hcb : c = b) (hcd : c = d)\n\nexample : a = d :=\n  Eq.trans (Eq.trans hab (Eq.symm hcb)) hcd\n```\nEquality is much more than an equivalence relation, however. It has the important property that every assertion\nrespects the equivalence, in the sense that we can substitute equal expressions without changing the truth value.\nThat is, given `h1 : a = b` and `h2 : p a`, we can construct a proof for `p b` using substitution: `Eq.subst h1 h2`.\nExample:\n```\nexample (α : Type) (a b : α) (p : α → Prop)\n        (h1 : a = b) (h2 : p a) : p b :=\n  Eq.subst h1 h2\n\nexample (α : Type) (a b : α) (p : α → Prop)\n    (h1 : a = b) (h2 : p a) : p b :=\n  h1 ▸ h2\n```\nThe triangle in the second presentation is a macro built on top of `Eq.subst` and `Eq.symm`, and you can enter it by typing `\\t`.\nFor more information: [Equality](https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `=` in identifiers is `eq`.</code>","179":"<code>HMul.hMul.{u, v, w} {α : Type u} {β : Type v} {γ : outParam (Type w)} [self : HMul α β γ] : α → β → γ</code><span class=\"sep\"></span><code class=\"docstring\">`a * b` computes the product of `a` and `b`.\nThe meaning of this notation is type-dependent. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `*` in identifiers is `mul`.</code>","18":"<code class=\"docstring\">The maximum of two universes.</code>","180":"<code class=\"docstring\">Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a term whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context,\n  generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero =&gt; tac₁ | succ x' ih =&gt; tac₂`\n  uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n</code>","181":"<code class=\"docstring\">After `with`, there is an optional tactic that runs on all branches, and\nthen a list of alternatives.\n</code>","182":"<code class=\"docstring\">The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or\nnon-dependent hypotheses. It has many variants:\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [h₁, h₂, ..., hₙ]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]` and the given `hᵢ`'s, where the `hᵢ`'s are expressions.-\n- If an `hᵢ` is a defined constant `f`, then `f` is unfolded. If `f` has equational lemmas associated\n  with it (and is not a projection or a `reducible` definition), these are used to rewrite with `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the\n  attribute `[simp]` and all hypotheses.\n- `simp only [h₁, h₂, ..., hₙ]` is like `simp [h₁, h₂, ..., hₙ]` but does not use `[simp]` lemmas.\n- `simp [-id₁, ..., -idₙ]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]`, but removes the ones named `idᵢ`.\n- `simp at h₁ h₂ ... hₙ` simplifies the hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. If\n  the target or another hypothesis depends on `hᵢ`, a new simplified hypothesis\n  `hᵢ` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the\n  other hypotheses.\n</code>","183":"<code>∀ (acc : ℕ), factAux k acc = acc * fct k</code>","184":"<code>HAdd.hAdd.{u, v, w} {α : Type u} {β : Type v} {γ : outParam (Type w)} [self : HAdd α β γ] : α → β → γ</code><span class=\"sep\"></span><code class=\"docstring\">`a + b` computes the sum of `a` and `b`.\nThe meaning of this notation is type-dependent. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `+` in identifiers is `add`.</code>","185":"<code class=\"docstring\">* `unfold id` unfolds all occurrences of definition `id` in the target.\n* `unfold id1 id2 ...` is equivalent to `unfold id1; unfold id2; ...`.\n* `unfold id at h` unfolds at the hypothesis `h`.\n\nDefinitions can be either global or local definitions.\n\nFor non-recursive global definitions, this tactic is identical to `delta`.\nFor recursive global definitions, it uses the \"unfolding lemma\" `id.eq_def`,\nwhich is generated for each recursive definition, to unfold according to the recursive definition given by the user.\nOnly one level of unfolding is performed, in contrast to `simp only [id]`, which unfolds definition `id` recursively.\n</code>","186":"<code class=\"docstring\">`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n</code>","187":"<code class=\"docstring\">`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n</code>","188":"<code>Nat.mul_assoc (n m k : ℕ) : n * m * k = n * (m * k)</code>","189":"<code>LeanW26.fct_fact : fact = fct</code>","19":"<code class=\"docstring\">The universe parameter v</code>","190":"<code class=\"docstring\">Apply function extensionality and introduce new hypotheses.\nThe tactic `funext` will keep applying the `funext` lemma until the goal target is not reducible to\n```\n  |-  ((fun x =&gt; ...) = (fun x =&gt; ...))\n```\nThe variant `funext h₁ ... hₙ` applies `funext` `n` times, and uses the given identifiers to name the new hypotheses.\nPatterns can be used like in the `intro` tactic. Example, given a goal\n```\n  |-  ((fun x : Nat × Bool =&gt; ...) = (fun x =&gt; ...))\n```\n`funext (a, b)` applies `funext` once and performs pattern matching on the newly introduced pair.\n</code>","191":"<code>LeanW26.is_even (x : ℕ) : Bool</code>","192":"<code>LeanW26.my_prop : Prop</code>","193":"<code>LeanW26.my_proof : my_prop</code>","194":"<code>Nat.zero_le (n : ℕ) : 0 ≤ n</code>","195":"<code>LeanW26.my_theorem : my_prop</code>","196":"<code>True : Prop</code><span class=\"sep\"></span><code class=\"docstring\">`True` is a proposition and has only an introduction rule, `True.intro : True`.\nIn other words, `True` is simply true, and has a canonical proof, `True.intro`\nFor more information: [Propositional Logic](https://lean-lang.org/theorem_proving_in_lean4/propositions_and_proofs.html#propositional-logic)\n</code>","197":"<code>False : Prop</code><span class=\"sep\"></span><code class=\"docstring\">`False` is the empty proposition. Thus, it has no introduction rules.\nIt represents a contradiction. `False` elimination rule, `False.rec`,\nexpresses the fact that anything follows from a contradiction.\nThis rule is sometimes called ex falso (short for ex falso sequitur quodlibet),\nor the principle of explosion.\nFor more information: [Propositional Logic](https://lean-lang.org/theorem_proving_in_lean4/propositions_and_proofs.html#propositional-logic)\n</code>","198":"<code>Int : Type</code><span class=\"sep\"></span><code class=\"docstring\">The integers.\n\nThis type is special-cased by the compiler and overridden with an efficient implementation. The\nruntime has a special representation for `Int` that stores “small” signed numbers directly, while\nlarger numbers use a fast arbitrary-precision arithmetic library (usually\n[GMP](https://gmplib.org/)). A “small number” is an integer that can be encoded with one fewer bits\nthan the platform's pointer size (i.e. 63 bits on 64-bit architectures and 31 bits on 32-bit\narchitectures).\n</code>","199":"<code>Rat : Type</code><span class=\"sep\"></span><code class=\"docstring\">Rational numbers, implemented as a pair of integers `num / den` such that the\ndenominator is positive and the numerator and denominator are coprime.\n</code>","2":"<code class=\"docstring\">A type universe. `Type ≡ Type 0`, `Type u ≡ Sort (u + 1)`. </code>","20":"<code>Type v</code>","200":"<code>Real : Type</code><span class=\"sep\"></span><code class=\"docstring\">The type `ℝ` of real numbers constructed as equivalence classes of Cauchy sequences of rational\nnumbers. </code>","201":"<code>Complex : Type</code><span class=\"sep\"></span><code class=\"docstring\">Complex numbers consist of two `Real`s: a real part `re` and an imaginary part `im`. </code>","202":"<code>Float : Type</code><span class=\"sep\"></span><code class=\"docstring\">64-bit floating-point numbers.\n\n`Float` corresponds to the IEEE 754 *binary64* format (`double` in C or `f64` in Rust).\nFloating-point numbers are a finite representation of a subset of the real numbers, extended with\nextra “sentinel” values that represent undefined and infinite results as well as separate positive\nand negative zeroes. Arithmetic on floating-point numbers approximates the corresponding operations\non the real numbers by rounding the results to numbers that are representable, propagating error and\ninfinite values.\n\nFloating-point numbers include [subnormal numbers](https://en.wikipedia.org/wiki/Subnormal_number).\nTheir special values are:\n * `NaN`, which denotes a class of “not a number” values that result from operations such as\n   dividing zero by zero, and\n * `Inf` and `-Inf`, which represent positive and infinities that result from dividing non-zero\n   values by zero.\n</code>","203":"<code>Float32 : Type</code><span class=\"sep\"></span><code class=\"docstring\">32-bit floating-point numbers.\n\n`Float32` corresponds to the IEEE 754 *binary32* format (`float` in C or `f32` in Rust).\nFloating-point numbers are a finite representation of a subset of the real numbers, extended with\nextra “sentinel” values that represent undefined and infinite results as well as separate positive\nand negative zeroes. Arithmetic on floating-point numbers approximates the corresponding operations\non the real numbers by rounding the results to numbers that are representable, propagating error and\ninfinite values.\n\nFloating-point numbers include [subnormal numbers](https://en.wikipedia.org/wiki/Subnormal_number).\nTheir special values are:\n * `NaN`, which denotes a class of “not a number” values that result from operations such as\n   dividing zero by zero, and\n * `Inf` and `-Inf`, which represent positive and infinities that result from dividing non-zero\n   values by zero.\n\n</code>","204":"<code>LeanW26.invert_rat (x : ℚ) : ℚ</code>","205":"<code>ℚ</code>","206":"<code>Rat.den (self : ℚ) : ℕ</code><span class=\"sep\"></span><code class=\"docstring\">The denominator of the rational number is a natural number. </code>","207":"<code>Rat.num (self : ℚ) : ℤ</code><span class=\"sep\"></span><code class=\"docstring\">The numerator of the rational number is an integer. </code>","208":"<code>LeanW26.invert_real (x : ℝ) : ℝ</code>","209":"<code>ℝ</code>","21":"<code>Prod.{u, v} (α : Type u) (β : Type v) : Type (max u v)</code><span class=\"sep\"></span><code class=\"docstring\">The product type, usually written `α × β`. Product types are also called pair or tuple types.\nElements of this type are pairs in which the first element is an `α` and the second element is a\n`β`.\n\nProducts nest to the right, so `(x, y, z) : α × β × γ` is equivalent to `(x, (y, z)) : α × (β × γ)`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `×` in identifiers is `Prod`.</code>","210":"<code>LeanW26.invert_invert : invert_real ∘ invert_real = id</code>","211":"<code>id.{u} {α : Sort u} (a : α) : α</code><span class=\"sep\"></span><code class=\"docstring\">The identity function. `id` takes an implicit argument `α : Sort u`\n(a type in any universe), and an argument `a : α`, and returns `a`.\n\nAlthough this may look like a useless function, one application of the identity\nfunction is to explicitly put a type on an expression. If `e` has type `T`,\nand `T'` is definitionally equal to `T`, then `@id T' e` typechecks, and Lean\nknows that this expression has type `T'` rather than `T`. This can make a\ndifference for typeclass inference, since `T` and `T'` may have different\ntypeclass instances on them. `show T' from e` is sugar for an `@id T' e`\nexpression.\n</code>","212":"<code>Function.comp.{u, v, w} {α : Sort u} {β : Sort v} {δ : Sort w} (f : β → δ) (g : α → β) : α → δ</code><span class=\"sep\"></span><code class=\"docstring\">Function composition, usually written with the infix operator `∘`. A new function is created from\ntwo existing functions, where one function's output is used as input to the other.\n\nExamples:\n * `Function.comp List.reverse (List.drop 2) [3, 2, 4, 1] = [1, 4]`\n * `(List.reverse ∘ List.drop 2) [3, 2, 4, 1] = [1, 4]`\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `∘` in identifiers is `comp`.</code>","213":"<code>Rat.ofInt (num : ℤ) : ℚ</code><span class=\"sep\"></span><code class=\"docstring\">Embedding of `Int` in the rational numbers. </code>","214":"<code>ℤ</code>","215":"<code>LeanW26.toRat (x : ℤ) : ℚ</code>","216":"<code>Char.toNat (c : Char) : ℕ</code><span class=\"sep\"></span><code class=\"docstring\">The character's Unicode code point as a `Nat`.\n</code>","217":"<code>Char.mk (val : UInt32) (valid : val.isValidChar) : Char</code>","218":"<code>UInt32</code>","219":"<code>UInt32.isValidChar (n : UInt32) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">A `UInt32` denotes a valid Unicode code point if it is less than `0x110000` and it is also not a\nsurrogate code point (the range `0xd800` to `0xdfff` inclusive).\n</code>","22":"<code class=\"docstring\">The impredicative maximum of two universes:\n\n * `imax u 0 = 0`\n * `imax u (v+1) = max u (v+1)`</code>","220":"<code class=\"docstring\">`aesop &lt;clause&gt;*` tries to solve the current goal by applying a set of rules\nregistered with the `@[aesop]` attribute. See [its\nREADME](https://github.com/JLimperg/aesop#readme) for a tutorial and a\nreference.\n\nThe variant `aesop?` prints the proof it found as a `Try this` suggestion.\n\nClauses can be used to customise the behaviour of an Aesop call. Available\nclauses are:\n\n- `(add &lt;phase&gt; &lt;priority&gt; &lt;builder&gt; &lt;rule&gt;)` adds a rule. `&lt;phase&gt;` is\n  `unsafe`, `safe` or `norm`. `&lt;priority&gt;` is a percentage for unsafe rules and\n  an integer for safe and norm rules. `&lt;rule&gt;` is the name of a declaration or\n  local hypothesis. `&lt;builder&gt;` is the rule builder used to turn `&lt;rule&gt;` into\n  an Aesop rule. Example: `(add unsafe 50% apply Or.inl)`.\n- `(erase &lt;rule&gt;)` disables a globally registered Aesop rule. Example: `(erase\n  Aesop.BuiltinRules.assumption)`.\n- `(rule_sets := [&lt;ruleset&gt;,*])` enables or disables named sets of rules for\n  this Aesop call. Example: `(rule_sets := [-builtin, MyRuleSet])`.\n- `(config { &lt;opt&gt; := &lt;value&gt; })` adjusts Aesop's search options. See\n  `Aesop.Options`.\n- `(simp_config { &lt;opt&gt; := &lt;value&gt; })` adjusts options for Aesop's built-in\n  `simp` rule. The given options are directly passed to `simp`. For example,\n  `(simp_config := { zeta := false })` makes Aesop use\n  `simp (config := { zeta := false })`.\n</code>","221":"<code>Char.isLower (c : Char) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Returns `true` if the character is a lowercase ASCII letter.\n\nThe lowercase ASCII letters are the following: `abcdefghijklmnopqrstuvwxyz`.\n</code>","222":"<code>Char.toUpper (c : Char) : Char</code><span class=\"sep\"></span><code class=\"docstring\">Converts a lowercase ASCII letter to the corresponding uppercase letter. Letters outside the ASCII\nalphabet are returned unchanged.\n\nThe lowercase ASCII letters are the following: `abcdefghijklmnopqrstuvwxyz`.\n</code>","223":"<code><span class=\"literal string\">\"uw\"</span> : String</code>","224":"<code>String.ofList (data : List Char) : String</code><span class=\"sep\"></span><code class=\"docstring\">Creates a string that contains the characters in a list, in order.\n\nExamples:\n* `['L', '∃', '∀', 'N'].asString = \"L∃∀N\"`\n* `[].asString = \"\"`\n* `['a', 'a', 'a'].asString = \"aaa\"`\n</code>","225":"<code><span class=\"literal string\">\"u\"</span> : String</code>","226":"<code><span class=\"literal string\">\"w\"</span> : String</code>","227":"<code>List Char</code>","228":"<code>String.mk (data : List Char) : String</code>","229":"<code><span class=\"literal string\">\"UW\"</span> : String</code>","23":"<code>LeanW26.Universes.MyProd.{u} (α β : Type u) : Type (u + 1)</code>","230":"<code>String.toUpper (s : String) : String</code><span class=\"sep\"></span><code class=\"docstring\">Replaces each character in `s` with the result of applying `Char.toUpper` to it.\n\n`Char.toUpper` has no effect on characters outside of the range `'a'`–`'z'`.\n\nExamples:\n* `\"orange\".toUpper = \"ORANGE\"`\n* `\"abc123\".toUpper = \"ABC123\"`\n</code>","231":"<code><span class=\"literal string\">\"uwece\"</span> : String</code>","232":"<code>LeanW26.f5 (L : List ℕ) : ℕ</code>","233":"<code>List ℕ</code>","234":"<code>List.nil.{u} {α : Type u} : List α</code><span class=\"sep\"></span><code class=\"docstring\">The empty list, usually written `[]`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `[]` in identifiers is `nil`.</code>","235":"<code>List.cons.{u} {α : Type u} (head : α) (tail : List α) : List α</code><span class=\"sep\"></span><code class=\"docstring\">The list whose first element is `head`, where `tail` is the rest of the list.\nUsually written `head :: tail`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `::` in identifiers is `cons`.\n\n * The recommended spelling of `[a]` in identifiers is `singleton`.</code>","236":"<code>LeanW26.map (f : ℕ → ℕ) (L : List ℕ) : List ℕ</code>","237":"<code>LeanW26.map' (f : ℕ → ℕ) (L : List ℕ) : List ℕ</code>","238":"<code>LeanW26.map_poly {A B : Type} (f : A → B) (L : List A) : List B</code>","239":"<code>A → B</code>","24":"<code>LeanW26.Universes.MyPropProd (α β : Prop) : Prop</code>","240":"<code>List A</code>","241":"<code>LeanW26.map_poly_explicit (A B : Type) (f : A → B) (L : List A) : List B</code>","242":"<code>Vector.{u} (α : Type u) (n : ℕ) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">`Vector α n` is an `Array α` with size `n`. </code>","243":"<code>Array.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">`Array α` is the type of [dynamic arrays](https://en.wikipedia.org/wiki/Dynamic_array) with elements\nfrom `α`. This type has special support in the runtime.\n\nArrays perform best when unshared. As long as there is never more than one reference to an array,\nall updates will be performed _destructively_. This results in performance comparable to mutable\narrays in imperative programming languages.\n\nAn array has a size and a capacity. The size is the number of elements present in the array, while\nthe capacity is the amount of memory currently allocated for elements. The size is accessible via\n`Array.size`, but the capacity is not observable from Lean code. `Array.emptyWithCapacity n` creates\nan array which is equal to `#[]`, but internally allocates an array of capacity `n`. When the size\nexceeds the capacity, allocation is required to grow the array.\n\nFrom the point of view of proofs, `Array α` is just a wrapper around `List α`.\n</code>","244":"<code>Set.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">A set is a collection of elements of some type `α`.\n\nAlthough `Set` is defined as `α → Prop`, this is an implementation detail which should not be\nrelied on. Instead, `setOf` and membership of a set (`∈`) should be used to convert between sets\nand predicates.\n</code>","245":"<code>Multiset.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">`Multiset α` is the quotient of `List α` by list permutation. The result\nis a type of finite sets with duplicates allowed. </code>","246":"<code>LeanW26.S1 : Set (Set Char)</code>","247":"<code>LeanW26.S2 : Set (List Char)</code>","248":"<code>LeanW26.S3 : List (Set Char)</code>","249":"<code>LeanW26.S4 : Array (Set Char)</code>","25":"<code>Prop</code>","250":"<code>Group.{u} (G : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">A `Group` is a `Monoid` with an operation `⁻¹` satisfying `a⁻¹ * a = 1`.\n\nThere is also a division operation `/` such that `a / b = a * b⁻¹`,\nwith a default so that `a / b = a * b⁻¹` holds by definition.\n\nUse `Group.ofLeftAxioms` or `Group.ofRightAxioms` to define a group structure\non a type with the minimum proof obligations.\n</code>","251":"<code>Type u_1</code>","252":"<code>G</code>","253":"<code>LeanW26.insert (x : ℕ) : List ℕ → List ℕ</code>","254":"<code>LeanW26.insertionSort : List ℕ → List ℕ</code>","255":"<code>LeanW26.str_cmp (a b : String) : Bool</code>","256":"<code>Decidable.decide (p : Prop) [h : Decidable p] : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Converts a decidable proposition into a `Bool`.\n\nIf `p : Prop` is decidable, then `decide p : Bool` is the Boolean value\nthat is `true` if `p` is true and `false` if `p` is false.\n</code>","257":"<code>2 * x &lt; 3 * y</code>","258":"<code>-4 * x + 2 * z &lt; 0</code>","259":"<code>12 * y - 4 * z &lt; 0</code>","26":"<code class=\"docstring\">`end` closes a `section` or `namespace` scope. If the scope is named `&lt;id&gt;`, it has to be closed\nwith `end &lt;id&gt;`. The `end` command is optional at the end of a file.\n</code>","260":"<code>LT.lt.{u} {α : Type u} [self : LT α] : α → α → Prop</code><span class=\"sep\"></span><code class=\"docstring\">The less-than relation: `x &lt; y` \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `&lt;` in identifiers is `lt`.</code>","261":"<code>HSub.hSub.{u, v, w} {α : Type u} {β : Type v} {γ : outParam (Type w)} [self : HSub α β γ] : α → β → γ</code><span class=\"sep\"></span><code class=\"docstring\">`a - b` computes the difference of `a` and `b`.\nThe meaning of this notation is type-dependent.\n* For natural numbers, this operator saturates at 0: `a - b = 0` when `a ≤ b`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `-` in identifiers is `sub` (when used as a binary operator).</code>","262":"<code class=\"docstring\">`linarith` attempts to find a contradiction between hypotheses that are linear (in)equalities.\nEquivalently, it can prove a linear inequality by assuming its negation and proving `False`.\n\nIn theory, `linarith` should prove any goal that is true in the theory of linear arithmetic over\nthe rationals. While there is some special handling for non-dense orders like `Nat` and `Int`,\nthis tactic is not complete for these theories and will not prove every true goal. It will solve\ngoals over arbitrary types that instantiate `CommRing`, `LinearOrder` and `IsStrictOrderedRing`.\n\nAn example:\n```lean\nexample (x y z : ℚ) (h1 : 2*x &lt; 3*y) (h2 : -4*x + 2*z &lt; 0)\n        (h3 : 12*y - 4* z &lt; 0) : False := by\n  linarith\n```\n\n`linarith` will use all appropriate hypotheses and the negation of the goal, if applicable.\nDisequality hypotheses require case splitting and are not normally considered\n(see the `splitNe` option below).\n\n`linarith [t1, t2, t3]` will additionally use proof terms `t1, t2, t3`.\n\n`linarith only [h1, h2, h3, t1, t2, t3]` will use only the goal (if relevant), local hypotheses\n`h1`, `h2`, `h3`, and proofs `t1`, `t2`, `t3`. It will ignore the rest of the local context.\n\n`linarith!` will use a stronger reducibility setting to try to identify atoms. For example,\n```lean\nexample (x : ℚ) : id x ≥ x := by\n  linarith\n```\nwill fail, because `linarith` will not identify `x` and `id x`. `linarith!` will.\nThis can sometimes be expensive.\n\n`linarith (config := { .. })` takes a config object with five\noptional arguments:\n* `discharger` specifies a tactic to be used for reducing an algebraic equation in the\n  proof stage. The default is `ring`. Other options include `simp` for basic\n  problems.\n* `transparency` controls how hard `linarith` will try to match atoms to each other. By default\n  it will only unfold `reducible` definitions.\n* If `splitHypotheses` is true, `linarith` will split conjunctions in the context into separate\n  hypotheses.\n* If `splitNe` is `true`, `linarith` will case split on disequality hypotheses.\n  For a given `x ≠ y` hypothesis, `linarith` is run with both `x &lt; y` and `x &gt; y`,\n  and so this runs linarith exponentially many times with respect to the number of\n  disequality hypotheses. (`false` by default.)\n* If `exfalso` is `false`, `linarith` will fail when the goal is neither an inequality nor `False`.\n  (`true` by default.)\n* If `minimize` is `false`, `linarith?` will report all hypotheses appearing in its initial\n  proof without attempting to drop redundancies. (`true` by default.)\n* `restrict_type` (not yet implemented in mathlib4)\n  will only use hypotheses that are inequalities over `tp`. This is useful\n  if you have e.g. both integer- and rational-valued inequalities in the local context, which can\n  sometimes confuse the tactic.\n\nA variant, `nlinarith`, does some basic preprocessing to handle some nonlinear goals.\n\nThe option `set_option trace.linarith true` will trace certain intermediate stages of the `linarith`\nroutine.\n</code>","263":"<code><span class=\"literal string\">\"1\"</span> : String</code>","264":"<code><span class=\"literal string\">\"hello world\"</span> : String</code>","265":"<code><span class=\"literal string\">\"hello\"</span> : String</code>","266":"<code>String.append (s : String) (t : String) : String</code><span class=\"sep\"></span><code class=\"docstring\">Appends two strings. Usually accessed via the `++` operator.\n\nThe internal implementation will perform destructive updates if the string is not shared.\n\nExamples:\n* `\"abc\".append \"def\" = \"abcdef\"`\n* `\"abc\" ++ \"def\" = \"abcdef\"`\n* `\"\" ++ \"\" = \"\"`\n</code>","267":"<code><span class=\"literal string\">\" world\"</span> : String</code>","268":"<code><span class=\"literal string\">\"everything is ok\"</span> : String</code>","269":"<code><span class=\"literal string\">\"the universe has a problem\"</span> : String</code>","27":"<code>LeanW26.Simple.A : Type 1</code>","270":"<code>Nat.Prime (p : ℕ) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">`Nat.Prime p` means that `p` is a prime number, that is, a natural number\nat least 2 whose only divisors are `p` and `1`.\nThe theorem `Nat.prime_def` witnesses this description of a prime number. </code>","271":"<code>my_amazing_result (p : Prop) : p → p</code>","272":"<code>a_less_amazing_result : True → True</code>","273":"<code>q → r</code>","274":"<code>And (a b : Prop) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">`And a b`, or `a ∧ b`, is the conjunction of propositions. It can be\nconstructed and destructed like a pair: if `ha : a` and `hb : b` then\n`⟨ha, hb⟩ : a ∧ b`, and if `h : a ∧ b` then `h.left : a` and `h.right : b`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `∧` in identifiers is `and`.\n\n * The recommended spelling of `/\\` in identifiers is `and` (prefer `∧` over `/\\`).</code>","275":"<code class=\"docstring\">The `sorry` tactic is a temporary placeholder for an incomplete tactic proof,\nclosing the main goal using `exact sorry`.\n\nThis is intended for stubbing-out incomplete parts of a proof while still having a syntactically correct proof skeleton.\nLean will give a warning whenever a proof uses `sorry`, so you aren't likely to miss it,\nbut you can double check if a theorem depends on `sorry` by looking for `sorryAx` in the output\nof the `#print axioms my_thm` command, the axiom used by the implementation of `sorry`.\n</code>","276":"<code class=\"docstring\">Introduces one or more hypotheses, optionally naming and/or pattern-matching them.\nFor each hypothesis to be introduced, the remaining main goal's target type must\nbe a `let` or function type.\n\n* `intro` by itself introduces one anonymous hypothesis, which can be accessed\n  by e.g. `assumption`. It is equivalent to `intro _`.\n* `intro x y` introduces two hypotheses and names them. Individual hypotheses\n  can be anonymized via `_`, given a type ascription, or matched against a pattern:\n  ```lean\n  -- ... ⊢ α × β → ...\n  intro (a, b)\n  -- ..., a : α, b : β ⊢ ...\n  ```\n* `intro rfl` is short for `intro h; subst h`, if `h` is an equality where the left-hand or right-hand side\n  is a variable.\n* Alternatively, `intro` can be combined with pattern matching much like `fun`:\n  ```lean\n  intro\n  | n + 1, 0 =&gt; tac\n  | ...\n  ```\n</code>","277":"<code class=\"docstring\">The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.\nThe definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.\n\n* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.\n* `have h := e` uses the type of `e` for `t`.\n* `have : t := e` and `have := e` use `this` for the name of the hypothesis.\n* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,\n  where `_` stands for the tactics that follow this one.\n  It is convenient for types that have only one applicable constructor.\n  For example, given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the\n  hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.\n* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,\n  which adds the equation `h : e = pat` to the local context.\n\nThe tactic supports all the same syntax variants and options as the `have` term.\n\n## Properties and relations\n\n* It is not possible to unfold a variable introduced using `have`, since the definition's value is forgotten.\n  The `let` tactic introduces definitions that can be unfolded.\n* The `have h : t := e` is like doing `let h : t := e; clear_value h`.\n* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.\n* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,\n  which may be important for performance reasons.\n    Consider using the equivalent `let +nondep` to indicate the intent.\n\n</code>","278":"<code>q</code>","279":"<code>r</code>","28":"<code>LeanW26.Simple.B : Type 1</code>","280":"<code class=\"docstring\">`exact e` closes the main goal if its target type matches that of `e`.\n</code>","281":"<code>remove_zeros (L : List ℕ) : List ℕ</code>","282":"<code>MyNat : Type</code>","283":"<code>MyNat.zero : MyNat</code>","284":"<code>MyNat.succ : MyNat → MyNat</code>","285":"<code>MyComplex : Type</code>","286":"<code>MyComplex.mk : ℝ → ℝ → MyComplex</code>","287":"<code>MyComplex.re (x : MyComplex) : ℝ</code>","288":"<code>MyComplex</code>","289":"<code>MyComplex.im (x : MyComplex) : ℝ</code>","29":"<code class=\"docstring\">Declares one or more typed variables, or modifies whether already-declared variables are\n  implicit.\n\nIntroduces variables that can be used in definitions within the same `namespace` or `section` block.\nWhen a definition mentions a variable, Lean will add it as an argument of the definition. This is\nuseful in particular when writing many definitions that have parameters in common (see below for an\nexample).\n\nVariable declarations have the same flexibility as regular function parameters. In particular they\ncan be [explicit, implicit][binder docs], or [instance implicit][tpil classes] (in which case they\ncan be anonymous). This can be changed, for instance one can turn explicit variable `x` into an\nimplicit one with `variable {x}`. Note that currently, you should avoid changing how variables are\nbound and declare new variables at the same time; see [issue 2789] for more on this topic.\n\nIn *theorem bodies* (i.e. proofs), variables are not included based on usage in order to ensure that\nchanges to the proof cannot change the statement of the overall theorem. Instead, variables are only\navailable to the proof if they have been mentioned in the theorem header or in an `include` command\nor are instance implicit and depend only on such variables.\n\nSee [*Variables and Sections* from Theorem Proving in Lean][tpil vars] for a more detailed\ndiscussion.\n\n[tpil vars]:\nhttps://lean-lang.org/theorem_proving_in_lean4/dependent_type_theory.html#variables-and-sections\n(Variables and Sections on Theorem Proving in Lean) [tpil classes]:\nhttps://lean-lang.org/theorem_proving_in_lean4/type_classes.html (Type classes on Theorem Proving in\nLean) [binder docs]:\nhttps://leanprover-community.github.io/mathlib4_docs/Lean/Expr.html#Lean.BinderInfo (Documentation\nfor the BinderInfo type) [issue 2789]: https://github.com/leanprover/lean4/issues/2789 (Issue 2789\non github)\n\n## Examples\n\n```lean\nsection\n  variable\n    {α : Type u}      -- implicit\n    (a : α)           -- explicit\n    [instBEq : BEq α] -- instance implicit, named\n    [Hashable α]      -- instance implicit, anonymous\n\n  def isEqual (b : α) : Bool :=\n    a == b\n\n  #check isEqual\n  -- isEqual.{u} {α : Type u} (a : α) [instBEq : BEq α] (b : α) : Bool\n\n  variable\n    {a} -- `a` is implicit now\n\n  def eqComm {b : α} := a == b ↔ b == a\n\n  #check eqComm\n  -- eqComm.{u} {α : Type u} {a : α} [instBEq : BEq α] {b : α} : Prop\nend\n```\n\nThe following shows a typical use of `variable` to factor out definition arguments:\n\n```lean\nvariable (Src : Type)\n\nstructure Logger where\n  trace : List (Src × String)\n#check Logger\n-- Logger (Src : Type) : Type\n\nnamespace Logger\n  -- switch `Src : Type` to be implicit until the `end Logger`\n  variable {Src}\n\n  def empty : Logger Src where\n    trace := []\n  #check empty\n  -- Logger.empty {Src : Type} : Logger Src\n\n  variable (log : Logger Src)\n\n  def len :=\n    log.trace.length\n  #check len\n  -- Logger.len {Src : Type} (log : Logger Src) : Nat\n\n  variable (src : Src) [BEq Src]\n\n  -- at this point all of `log`, `src`, `Src` and the `BEq` instance can all become arguments\n\n  def filterSrc :=\n    log.trace.filterMap\n      fun (src', str') =&gt; if src' == src then some str' else none\n  #check filterSrc\n  -- Logger.filterSrc {Src : Type} (log : Logger Src) (src : Src) [inst✝ : BEq Src] : List String\n\n  def lenSrc :=\n    log.filterSrc src |&gt;.length\n  #check lenSrc\n  -- Logger.lenSrc {Src : Type} (log : Logger Src) (src : Src) [inst✝ : BEq Src] : Nat\nend Logger\n```\n\nThe following example demonstrates availability of variables in proofs:\n```lean\nvariable\n  {α : Type}    -- available in the proof as indirectly mentioned through `a`\n  [ToString α]  -- available in the proof as `α` is included\n  (a : α)       -- available in the proof as mentioned in the header\n  {β : Type}    -- not available in the proof\n  [ToString β]  -- not available in the proof\n\ntheorem ex : a = a := rfl\n```\nAfter elaboration of the proof, the following warning will be generated to highlight the unused\nhypothesis:\n```\nincluded section variable '[ToString α]' is not used in 'ex', consider excluding it\n```\nIn such cases, the offending variable declaration should be moved down or into a section so that\nonly theorems that do depend on it follow it until the end of the section.\n</code>","290":"<code>MyComplex.abs (x : MyComplex) : ℝ</code>","291":"<code>Real.sqrt (x : ℝ) : ℝ</code><span class=\"sep\"></span><code class=\"docstring\">The square root of a real number. This returns 0 for negative inputs.\n\nThis has notation `√x`. Note that `√x⁻¹` is parsed as `√(x⁻¹)`. </code>","292":"<code>TriBool : Type</code>","293":"<code>TriBool.T : TriBool</code>","294":"<code>TriBool.F : TriBool</code>","295":"<code>TriBool.U : TriBool</code>","296":"<code>_root_.and (A B : TriBool) : TriBool</code>","297":"<code>TriBool</code>","298":"<code>BTree (A : Type) : Type</code>","299":"<code>BTree.leaf {A : Type} : A → BTree A</code>","3":"<code class=\"docstring\">The universe level 0</code>","30":"<code>A</code>","300":"<code>BTree.node {A : Type} : A → BTree A → BTree A → BTree A</code>","301":"<code>my_tree : BTree ℕ</code>","302":"<code>to_list {A : Type} (T : BTree A) : List A</code>","303":"<code>BTree A</code>","304":"<code>to_str {A : Type} [sa : ToString A] (T : BTree A) : String</code>","305":"<code>ToString A</code>","306":"<code>ToString.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">Types that can be converted into a string for display.\n\nThere is no expectation that the resulting string can be parsed back to the original data (see\n`Repr` for a similar class with this expectation).\n</code>","307":"<code>ToString.toString.{u} {α : Type u} [self : ToString α] : α → String</code><span class=\"sep\"></span><code class=\"docstring\">Converts a value into a string. </code>","308":"<code><span class=\"literal string\">\"(\"</span> : String</code>","309":"<code><span class=\"literal string\">\" \"</span> : String</code>","31":"<code>A → A</code>","310":"<code><span class=\"literal string\">\")\"</span> : String</code>","311":"<code>Repr.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">The standard way of turning values of some type into `Format`.\n\nWhen rendered this `Format` should be as close as possible to something that can be parsed as the\ninput value.\n</code>","312":"<code>BTree A → ℕ → Std.Format</code><span class=\"sep\"></span><code class=\"docstring\">Turn a value of type `α` into a `Format` at a given precedence. The precedence value can be used\nto avoid parentheses if they are not necessary.\n</code>","313":"<code>bt_map {A B : Type} (f : A → B) (T : BTree A) : BTree B</code>","314":"<code>Komplex : Type</code>","315":"<code>Komplex.re (self : Komplex) : ℝ</code>","316":"<code>Komplex.im (self : Komplex) : ℝ</code>","317":"<code>conj (x : Komplex) : Komplex</code>","318":"<code>Komplex</code>","319":"<code>ℝ</code>","32":"<code>LeanW26.Simple.inc₁ (x : ℕ) : ℕ</code>","320":"<code>add (x y : Komplex) : Komplex</code>","321":"<code>Komplex.mk (re im : ℝ) : Komplex</code>","322":"<code>negate (x : Komplex) : Komplex</code>","323":"<code>negate1 (x : Komplex) : Komplex</code>","324":"<code>negate2 (x : Komplex) : Komplex</code>","325":"<code>negate3 (x : Komplex) : Komplex</code>","326":"<code>negate4 (x : Komplex) : Komplex</code>","327":"<code>MyProd (A B : Type) : Type</code>","328":"<code>MyProd.fst {A B : Type} (self : MyProd A B) : A</code>","329":"<code>MyProd.snd {A B : Type} (self : MyProd A B) : B</code>","33":"<code>ℕ</code>","330":"<code>p : MyProd ℚ String</code>","331":"<code>MyProd.mk {A B : Type} (fst : A) (snd : B) : MyProd A B</code>","332":"<code><span class=\"literal string\">\"zero\"</span> : String</code>","333":"<code>q : ℚ × String</code>","334":"<code>Prod.mk.{u, v} {α : Type u} {β : Type v} (fst : α) (snd : β) : α × β</code><span class=\"sep\"></span><code class=\"docstring\">Constructs a pair. This is usually written `(x, y)` instead of `Prod.mk x y`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `(a, b)` in identifiers is `mk`.</code>","335":"<code><span class=\"literal string\">\"one\"</span> : String</code>","336":"<code>MySum (A B : Type) : Type</code>","337":"<code>MySum.inl {A B : Type} : A → MySum A B</code>","338":"<code>MySum.inr {A B : Type} : B → MySum A B</code>","339":"<code>s1 : MySum ℚ String</code>","34":"<code>LeanW26.Simple.inc₂ (x : ℕ) : ℕ</code>","340":"<code>s2 : MySum ℚ String</code>","341":"<code>swap (s : MySum ℚ String) : MySum String ℚ</code>","342":"<code>MySum ℚ String</code>","343":"<code>s : ℚ ⊕ String</code>","344":"<code>Sum.inl.{u, v} {α : Type u} {β : Type v} (val : α) : α ⊕ β</code><span class=\"sep\"></span><code class=\"docstring\">Left injection into the sum type `α ⊕ β`. </code>","345":"<code>MyOption (A : Type) : Type</code>","346":"<code>MyOption.none {A : Type} : MyOption A</code>","347":"<code>MyOption.some {A : Type} : A → MyOption A</code>","348":"<code>first {A : Type} (L : List A) : MyOption A</code>","349":"<code>my_func (L : List ℕ) : List ℕ</code>","35":"<code class=\"docstring\">`#eval e` evaluates the expression `e` by compiling and evaluating it.\n\n* The command attempts to use `ToExpr`, `Repr`, or `ToString` instances to print the result.\n* If `e` is a monadic value of type `m ty`, then the command tries to adapt the monad `m`\n  to one of the monads that `#eval` supports, which include `IO`, `CoreM`, `MetaM`, `TermElabM`, and `CommandElabM`.\n  Users can define `MonadEval` instances to extend the list of supported monads.\n\nThe `#eval` command gracefully degrades in capability depending on what is imported.\nImporting the `Lean.Elab.Command` module provides full capabilities.\n\nDue to unsoundness, `#eval` refuses to evaluate expressions that depend on `sorry`, even indirectly,\nsince the presence of `sorry` can lead to runtime instability and crashes.\nThis check can be overridden with the `#eval! e` command.\n\nOptions:\n* If `eval.pp` is true (default: true) then tries to use `ToExpr` instances to make use of the\n  usual pretty printer. Otherwise, only tries using `Repr` and `ToString` instances.\n* If `eval.type` is true (default: false) then pretty prints the type of the evaluated value.\n* If `eval.derive.repr` is true (default: true) then attempts to auto-derive a `Repr` instance\n  when there is no other way to print the result.\n\nSee also: `#reduce e` for evaluation by term reduction.\n</code>","350":"<code>MyOption ℕ</code>","351":"<code>MyNat.add (x y : MyNat) : MyNat</code>","352":"<code>MyNat</code>","353":"<code class=\"docstring\">`infix:prec \"op\" =&gt; f` is equivalent to `notation:prec x:prec1 \"op\" y:prec1 =&gt; f x y`, where `prec1 := prec + 1`.\n</code>","354":"<code><span class=\"literal string\">\" + \"</span> : String</code>","355":"<code>Temp.Dyadic : Type</code>","356":"<code>Temp.Dyadic.zero : Dyadic</code>","357":"<code>Temp.Dyadic.add_one : Dyadic → Dyadic</code>","358":"<code>Temp.Dyadic.half : Dyadic → Dyadic</code>","359":"<code class=\"docstring\">`set_option &lt;id&gt; &lt;value&gt;` sets the option `&lt;id&gt;` to `&lt;value&gt;`. Depending on the type of the option,\nthe value can be `true`, `false`, a string, or a numeral. Options are used to configure behavior of\nLean as well as user-defined extensions. The setting is active until the end of the current `section`\nor `namespace` or the end of the file.\nAuto-completion is available for `&lt;id&gt;` to list available options.\n\n`set_option &lt;id&gt; &lt;value&gt; in &lt;command&gt;` sets the option for just a single command:\n```\nset_option pp.all true in\n#check 1 + 1\n```\nSimilarly, `set_option &lt;id&gt; &lt;value&gt; in` can also be used inside terms and tactics to set an option\nonly in a single term or tactic.\n</code>","36":"<code>Type</code>","360":"<code>doc.verso</code><span class=\"sep\"></span><code class=\"docstring\">whether to use Verso syntax in docstrings</code>","361":"<code class=\"docstring\">Marks a theorem or definition for use by the `grind` tactic.\n\nAn optional modifier (e.g. `=`, `→`, `←`, `cases`, `intro`, `ext`, `inj`, etc.)\ncontrols how `grind` uses the declaration:\n* whether it is applied forwards, backwards, or both,\n* whether equalities are used on the left, right, or both sides,\n* whether case-splits, constructors, extensionality, or injectivity are applied,\n* or whether custom instantiation patterns are used.\n\nSee the individual modifier docstrings for details.\n</code>","362":"<code>SameContents.{u_1} {α : Type u_1} (xs ys : List α) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">Two lists `xs` and `ys` have the same contents iff any element of one is also an element\nof the other\\.\n</code>","363":"<code>SameContents.inOne.{u_1} {α : Type u_1} {xs ys : List α} (self : SameContents xs ys) (x : α) : x ∈ xs → x ∈ ys</code>","364":"<code>SameContents.inOther.{u_1} {α : Type u_1} {xs ys : List α} (self : SameContents xs ys) (y : α) : y ∈ ys → y ∈ xs</code>","365":"<code>SameContents.refl.{u_1} {α : Type u_1} (xs : List α) : SameContents xs xs</code><span class=\"sep\"></span><code class=\"docstring\">Every list has the same contents as itself\\. That is, `SameContents` is reflexive\\.\n</code>","366":"<code class=\"docstring\">If the main goal's target type is an inductive type, `constructor` solves it with\nthe first matching constructor, or else fails.\n</code>","367":"<code>Membership.mem.{u, v} {α : outParam (Type u)} {γ : Type v} [self : Membership α γ] : γ → α → Prop</code><span class=\"sep\"></span><code class=\"docstring\">The membership relation `a ∈ s : Prop` where `a : α`, `s : γ`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `∈` in identifiers is `mem`.</code>","368":"<code class=\"docstring\">`grind` is a tactic inspired by modern SMT solvers. **Picture a virtual whiteboard**:\nevery time grind discovers a new equality, inequality, or logical fact,\nit writes it on the board, groups together terms known to be equal,\nand lets each reasoning engine read from and contribute to the shared workspace.\nThese engines work together to handle equality reasoning, apply known theorems,\npropagate new facts, perform case analysis, and run specialized solvers\nfor domains like linear arithmetic and commutative rings.\n\n`grind` is *not* designed for goals whose search space explodes combinatorially,\nthink large pigeonhole instances, graph‑coloring reductions, high‑order N‑queens boards,\nor a 200‑variable Sudoku encoded as Boolean constraints.  Such encodings require\n thousands (or millions) of case‑splits that overwhelm `grind`’s branching search.\n\nFor **bit‑level or combinatorial problems**, consider using **`bv_decide`**.\n`bv_decide` calls a state‑of‑the‑art SAT solver (CaDiCaL) and then returns a\n*compact, machine‑checkable certificate*.\n\n### Equality reasoning\n\n`grind` uses **congruence closure** to track equalities between terms.\nWhen two terms are known to be equal, congruence closure automatically deduces\nequalities between more complex expressions built from them.\nFor example, if `a = b`, then congruence closure will also conclude that `f a` = `f b`\nfor any function `f`. This forms the foundation for efficient equality reasoning in `grind`.\nHere is an example:\n```\nexample (f : Nat → Nat) (h : a = b) : f (f b) = f (f a) := by\n  grind\n```\n\n### Applying theorems using E-matching\n\nTo apply existing theorems, `grind` uses a technique called **E-matching**,\nwhich finds matches for known theorem patterns while taking equalities into account.\nCombined with congruence closure, E-matching helps `grind` discover\nnon-obvious consequences of theorems and equalities automatically.\n\nConsider the following functions and theorems:\n```\ndef f (a : Nat) : Nat :=\n  a + 1\n\ndef g (a : Nat) : Nat :=\n  a - 1\n\n@[grind =]\ntheorem gf (x : Nat) : g (f x) = x := by\n  simp [f, g]\n```\nThe theorem `gf` asserts that `g (f x) = x` for all natural numbers `x`.\nThe attribute `[grind =]` instructs `grind` to use the left-hand side of the equation,\n`g (f x)`, as a pattern for E-matching.\nSuppose we now have a goal involving:\n```\nexample {a b} (h : f b = a) : g a = b := by\n  grind\n```\nAlthough `g a` is not an instance of the pattern `g (f x)`,\nit becomes one modulo the equation `f b = a`. By substituting `a`\nwith `f b` in `g a`, we obtain the term `g (f b)`,\nwhich matches the pattern `g (f x)` with the assignment `x := b`.\nThus, the theorem `gf` is instantiated with `x := b`,\nand the new equality `g (f b) = b` is asserted.\n`grind` then uses congruence closure to derive the implied equality\n`g a = g (f b)` and completes the proof.\n\nThe pattern used to instantiate theorems affects the effectiveness of `grind`.\nFor example, the pattern `g (f x)` is too restrictive in the following case:\nthe theorem `gf` will not be instantiated because the goal does not even\ncontain the function symbol `g`.\n\n```\nexample (h₁ : f b = a) (h₂ : f c = a) : b = c := by\n  grind\n```\n\nYou can use the command `grind_pattern` to manually select a pattern for a given theorem.\nIn the following example, we instruct `grind` to use `f x` as the pattern,\nallowing it to solve the goal automatically:\n```\ngrind_pattern gf =&gt; f x\n\nexample {a b c} (h₁ : f b = a) (h₂ : f c = a) : b = c := by\n  grind\n```\nYou can enable the option `trace.grind.ematch.instance` to make `grind` print a\ntrace message for each theorem instance it generates.\n\nYou can also specify a **multi-pattern** to control when `grind` should apply a theorem.\nA multi-pattern requires that all specified patterns are matched in the current context\nbefore the theorem is applied. This is useful for theorems such as transitivity rules,\nwhere multiple premises must be simultaneously present for the rule to apply.\nThe following example demonstrates this feature using a transitivity axiom for a binary relation `R`:\n```\nopaque R : Int → Int → Prop\naxiom Rtrans {x y z : Int} : R x y → R y z → R x z\n\ngrind_pattern Rtrans =&gt; R x y, R y z\n\nexample {a b c d} : R a b → R b c → R c d → R a d := by\n  grind\n```\nBy specifying the multi-pattern `R x y, R y z`, we instruct `grind` to\ninstantiate `Rtrans` only when both `R x y` and `R y z` are available in the context.\nIn the example, `grind` applies `Rtrans` to derive `R a c` from `R a b` and `R b c`,\nand can then repeat the same reasoning to deduce `R a d` from `R a c` and `R c d`.\n\nInstead of using `grind_pattern` to explicitly specify a pattern,\nyou can use the `@[grind]` attribute or one of its variants, which will use a heuristic to\ngenerate a (multi-)pattern. The complete list is available in the reference manual. The main ones are:\n\n- `@[grind →]` will select a multi-pattern from the hypotheses of the theorem (i.e. it will use the theorem for forwards reasoning).\n  In more detail, it will traverse the hypotheses of the theorem from left-to-right, and each time it encounters a minimal indexable\n  (i.e. has a constant as its head) subexpression which \"covers\" (i.e. fixes the value of) an argument which was not\n  previously covered, it will add that subexpression as a pattern, until all arguments have been covered.\n- `@[grind ←]` will select a multi-pattern from the conclusion of theorem (i.e. it will use the theorem for backwards reasoning).\n  This may fail if not all the arguments to the theorem appear in the conclusion.\n- `@[grind]` will traverse the conclusion and then the hypotheses left-to-right, adding patterns as they increase the coverage,\n  stopping when all arguments are covered.\n- `@[grind =]` checks that the conclusion of the theorem is an equality, and then uses the left-hand-side of the equality as a pattern.\n  This may fail if not all of the arguments appear in the left-hand-side.\n\nHere is the previous example again but using the attribute `[grind →]`\n```\nopaque R : Int → Int → Prop\n@[grind →] axiom Rtrans {x y z : Int} : R x y → R y z → R x z\n\nexample {a b c d} : R a b → R b c → R c d → R a d := by\n  grind\n```\n\nTo control theorem instantiation and avoid generating an unbounded number of instances,\n`grind` uses a generation counter. Terms in the original goal are assigned generation zero.\nWhen `grind` applies a theorem using terms of generation `≤ n`, any new terms it creates\nare assigned generation `n + 1`. This limits how far the tactic explores when applying\ntheorems and helps prevent an excessive number of instantiations.\n\n#### Key options:\n- `grind (ematch := &lt;num&gt;)` controls the number of E-matching rounds.\n- `grind [&lt;name&gt;, ...]` instructs `grind` to use the declaration `name` during E-matching.\n- `grind only [&lt;name&gt;, ...]` is like `grind [&lt;name&gt;, ...]` but does not use theorems tagged with `@[grind]`.\n- `grind (gen := &lt;num&gt;)` sets the maximum generation.\n\n### Linear integer arithmetic (`cutsat`)\n\n`grind` can solve goals that reduce to **linear integer arithmetic (LIA)** using an\nintegrated decision procedure called **`cutsat`**.  It understands\n\n* equalities   `p = 0`\n* inequalities  `p ≤ 0`\n* disequalities `p ≠ 0`\n* divisibility  `d ∣ p`\n\nThe solver incrementally assigns integer values to variables; when a partial\nassignment violates a constraint it adds a new, implied constraint and retries.\nThis *model-based* search is **complete for LIA**.\n\n#### Key options:\n\n* `grind -cutsat` disable the solver (useful for debugging)\n* `grind +qlia` accept rational models (shrinks the search space but is incomplete for ℤ)\n\n#### Examples:\n\n```\n-- Even + even is never odd.\nexample {x y : Int} : 2 * x + 4 * y ≠ 5 := by\n  grind\n\n-- Mixing equalities and inequalities.\nexample {x y : Int} :\n    2 * x + 3 * y = 0 → 1 ≤ x → y &lt; 1 := by\n  grind\n\n-- Reasoning with divisibility.\nexample (a b : Int) :\n    2 ∣ a + 1 → 2 ∣ b + a → ¬ 2 ∣ b + 2 * a := by\n  grind\n\nexample (x y : Int) :\n    27 ≤ 11*x + 13*y →\n    11*x + 13*y ≤ 45 →\n    -10 ≤ 7*x - 9*y →\n    7*x - 9*y ≤ 4 → False := by\n  grind\n\n-- Types that implement the `ToInt` type-class.\nexample (a b c : UInt64)\n    : a ≤ 2 → b ≤ 3 → c - a - b = 0 → c ≤ 5 := by\n  grind\n```\n\n### Algebraic solver (`ring`)\n\n`grind` ships with an algebraic solver nick-named **`ring`** for goals that can\nbe phrased as polynomial equations (or disequations) over commutative rings,\nsemirings, or fields.\n\n*Works out of the box*\nAll core numeric types and relevant Mathlib types already provide the required\ntype-class instances, so the solver is ready to use in most developments.\n\nWhat it can decide:\n\n* equalities of the form `p = q`\n* disequalities `p ≠ q`\n* basic reasoning under field inverses (`a / b := a * b⁻¹`)\n* goals that mix ring facts with other `grind` engines\n\n#### Key options:\n\n* `grind -ring` turn the solver off (useful when debugging)\n* `grind (ringSteps := n)` cap the number of steps performed by this procedure.\n\n#### Examples\n\n```\nopen Lean Grind\n\nexample [CommRing α] (x : α) : (x + 1) * (x - 1) = x^2 - 1 := by\n  grind\n\n-- Characteristic 256 means 16 * 16 = 0.\nexample [CommRing α] [IsCharP α 256] (x : α) :\n    (x + 16) * (x - 16) = x^2 := by\n  grind\n\n-- Works on built-in rings such as `UInt8`.\nexample (x : UInt8) : (x + 16) * (x - 16) = x^2 := by\n  grind\n\nexample [CommRing α] (a b c : α) :\n    a + b + c = 3 →\n    a^2 + b^2 + c^2 = 5 →\n    a^3 + b^3 + c^3 = 7 →\n    a^4 + b^4 = 9 - c^4 := by\n  grind\n\nexample [Field α] [NoNatZeroDivisors α] (a : α) :\n    1 / a + 1 / (2 * a) = 3 / (2 * a) := by\n  grind\n```\n\n### Other options\n\n- `grind (splits := &lt;num&gt;)` caps the *depth* of the search tree.  Once a branch performs `num` splits\n  `grind` stops splitting further in that branch.\n- `grind -splitIte` disables case splitting on if-then-else expressions.\n- `grind -splitMatch` disables case splitting on `match` expressions.\n- `grind +splitImp` instructs `grind` to split on any hypothesis `A → B` whose antecedent `A` is **propositional**.\n- `grind -linarith` disables the linear arithmetic solver for (ordered) modules and rings.\n\n### Additional Examples\n\n```\nexample {a b} {as bs : List α} : (as ++ bs ++ [b]).getLastD a = b := by\n  grind\n\nexample (x : BitVec (w+1)) : (BitVec.cons x.msb (x.setWidth w)) = x := by\n  grind\n\nexample (as : Array α) (lo hi i j : Nat) :\n    lo ≤ i → i &lt; j → j ≤ hi → j &lt; as.size → min lo (as.size - 1) ≤ i := by\n  grind\n```\n</code>","369":"<code class=\"docstring\">Theorems tagged with the `simp` attribute are used by the simplifier\n(i.e., the `simp` tactic, and its variants) to simplify expressions occurring in your goals.\nWe call theorems tagged with the `simp` attribute \"simp theorems\" or \"simp lemmas\".\nLean maintains a database/index containing all active simp theorems.\nHere is an example of a simp theorem.\n```lean\n@[simp] theorem ne_eq (a b : α) : (a ≠ b) = Not (a = b) := rfl\n```\nThis simp theorem instructs the simplifier to replace instances of the term\n`a ≠ b` (e.g. `x + 0 ≠ y`) with `Not (a = b)` (e.g., `Not (x + 0 = y)`).\nThe simplifier applies simp theorems in one direction only:\nif `A = B` is a simp theorem, then `simp` replaces `A`s with `B`s,\nbut it doesn't replace `B`s with `A`s. Hence a simp theorem should have the\nproperty that its right-hand side is \"simpler\" than its left-hand side.\nIn particular, `=` and `↔` should not be viewed as symmetric operators in this situation.\nThe following would be a terrible simp theorem (if it were even allowed):\n```lean\n@[simp] lemma mul_right_inv_bad (a : G) : 1 = a * a⁻¹ := ...\n```\nReplacing 1 with a * a⁻¹ is not a sensible default direction to travel.\nEven worse would be a theorem that causes expressions to grow without bound,\ncausing simp to loop forever.\n\nBy default the simplifier applies `simp` theorems to an expression `e`\nafter its sub-expressions have been simplified.\nWe say it performs a bottom-up simplification.\nYou can instruct the simplifier to apply a theorem before its sub-expressions\nhave been simplified by using the modifier `↓`. Here is an example\n```lean\n@[simp↓] theorem not_and_eq (p q : Prop) : (¬ (p ∧ q)) = (¬p ∨ ¬q) :=\n```\n\nYou can instruct the simplifier to rewrite the lemma from right-to-left:\n```lean\nattribute @[simp ←] and_assoc\n```\n\nWhen multiple simp theorems are applicable, the simplifier uses the one with highest priority.\nThe equational theorems of functions are applied at very low priority (100 and below).\nIf there are several with the same priority, it is uses the \"most recent one\". Example:\n```lean\n@[simp high] theorem cond_true (a b : α) : cond true a b = a := rfl\n@[simp low+1] theorem or_true (p : Prop) : (p ∨ True) = True :=\n  propext &lt;| Iff.intro (fun _ =&gt; trivial) (fun _ =&gt; Or.inr trivial)\n@[simp 100] theorem ite_self {d : Decidable c} (a : α) : ite c a a = a := by\n  cases d &lt;;&gt; rfl\n```\n</code>","37":"<code>Type → Type</code>","370":"<code>SameContents.symm.{u_1} {α✝ : Type u_1} {xs ys : List α✝} : SameContents xs ys → SameContents ys xs</code><span class=\"sep\"></span><code class=\"docstring\">`SameContents` is symmetric\\.\n</code>","371":"<code>List ?m.4</code>","372":"<code>List α✝</code>","373":"<code>∀ (x : α✝), x ∈ xs → x ∈ ys</code>","374":"<code>∀ (y : α✝), y ∈ ys → y ∈ xs</code>","375":"<code class=\"docstring\">`assumption` tries to solve the main goal using a hypothesis of compatible type, or else fails.\nNote also the `‹t›` term notation, which is a shorthand for `show t by assumption`.\n</code>","376":"<code>SameContents.trans.{u_1} {α✝ : Type u_1} {xs ys zs : List α✝} :\n  SameContents xs ys → SameContents ys zs → SameContents xs zs</code><span class=\"sep\"></span><code class=\"docstring\">`SameContents` is transitive\\.\n</code>","377":"<code>List ?m.5</code>","378":"<code>∀ (x : α✝), x ∈ ys → x ∈ zs</code>","379":"<code>∀ (y : α✝), y ∈ zs → y ∈ ys</code>","38":"<code>LeanW26.Simple.c (x : Type) : Type</code>","380":"<code>List.{u} (α : Type u) : Type u</code>","381":"<code>SameContents.setoid.{u_1} {α : Type u_1} : Setoid (List α)</code><span class=\"sep\"></span><code class=\"docstring\">`SameContents` and `List α` form a setoid\\.\n</code>","382":"<code>Setoid.{u} (α : Sort u) : Sort (max 1 u)</code><span class=\"sep\"></span><code class=\"docstring\">A setoid is a type with a distinguished equivalence relation, denoted `≈`.\n\nThe `Quotient` type constructor requires a `Setoid` instance.\n</code>","383":"<code>List α → List α → Prop</code><span class=\"sep\"></span><code class=\"docstring\">`x ≈ y` is the distinguished equivalence relation of a setoid. </code>","384":"<code>Equivalence SameContents</code><span class=\"sep\"></span><code class=\"docstring\">The relation `x ≈ y` is an equivalence relation. </code>","385":"<code>Equivalence.mk.{u} {α : Sort u} {r : α → α → Prop} (refl : ∀ (x : α), r x x) (symm : ∀ {x y : α}, r x y → r y x)\n  (trans : ∀ {x y z : α}, r x y → r y z → r x z) : Equivalence r</code>","386":"<code>SameContents.empty.{u_1} {α✝ : Type u_1} {xs : List α✝} : SameContents [] xs → xs = []</code><span class=\"sep\"></span><code class=\"docstring\">If `xs` has the same elements as the empty list, then `xs` is itself empty\\.\n</code>","387":"<code>∀ (x : α✝), x ∈ [] → x ∈ xs</code>","388":"<code>∀ (y : α✝), y ∈ xs → y ∈ []</code>","389":"<code class=\"docstring\">Assuming `x` is a variable in the local context with an inductive type,\n`cases x` splits the main goal, producing one goal for each constructor of the\ninductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well.\n`cases` detects unreachable cases and closes them automatically.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`.\nHere the name `a` is chosen automatically and is not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal,\n  and then cases on the resulting variable.\n- Given `as : List α`, `cases as with | nil =&gt; tac₁ | cons a as' =&gt; tac₂`,\n  uses tactic `tac₁` for the `nil` case, and `tac₂` for the `cons` case,\n  and `a` and `as'` are used as names for the new variables introduced.\n- `cases h : e`, where `e` is a variable or an expression,\n  performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis,\n  where `...` is the constructor instance for that particular case.\n</code>","39":"<code class=\"docstring\">`#reduce &lt;expression&gt;` reduces the expression `&lt;expression&gt;` to its normal form. This\ninvolves applying reduction rules until no further reduction is possible.\n\nBy default, proofs and types within the expression are not reduced. Use modifiers\n`(proofs := true)`  and `(types := true)` to reduce them.\nRecall that propositions are types in Lean.\n\n**Warning:** This can be a computationally expensive operation,\nespecially for complex expressions.\n\nConsider using `#eval &lt;expression&gt;` for simple evaluation/execution\nof expressions.\n</code>","390":"<code>∀ (x : α✝), x ∈ [] → x ∈ []</code>","391":"<code>∀ (y : α✝), y ∈ [] → y ∈ []</code>","392":"<code>∀ (x : α✝), x ∈ [] → x ∈ head✝ :: tail✝</code>","393":"<code>∀ (y : α✝), y ∈ head✝ :: tail✝ → y ∈ []</code>","394":"<code class=\"docstring\">This tactic applies to a goal whose target has the form `x ~ x`,\nwhere `~` is equality, heterogeneous equality or any relation that\nhas a reflexivity lemma tagged with the attribute @[refl].\n</code>","395":"<code class=\"docstring\">`rename_i x_1 ... x_n` renames the last `n` inaccessible names using the given names. </code>","396":"<code>∀ (x : α✝), x ∈ [] → x ∈ hd :: tl</code>","397":"<code>∀ (y : α✝), y ∈ hd :: tl → y ∈ []</code>","398":"<code>hd ∈ hd :: tl → hd ∈ []</code>","399":"<code class=\"docstring\">`simp_all` is a stronger version of `simp [*] at *` where the hypotheses and target\nare simplified multiple times until no simplification is applicable.\nOnly non-dependent propositional hypotheses are considered.\n</code>","4":"<code class=\"docstring\">The universe level 12</code>","40":"<code>LeanW26.Simple.h₁ (y : A) : A</code>","400":"<code>SameContents.append_eq.{u_1} {α✝ : Type u_1} {xs xs' ys ys' : List α✝} :\n  SameContents xs xs' → SameContents ys ys' → SameContents (xs ++ ys) (xs' ++ ys')</code><span class=\"sep\"></span><code class=\"docstring\">If lists have the same contents, then so do the results of appending them\\.\n</code>","401":"<code>List ?m.6</code>","402":"<code>HAppend.hAppend.{u, v, w} {α : Type u} {β : Type v} {γ : outParam (Type w)} [self : HAppend α β γ] : α → β → γ</code><span class=\"sep\"></span><code class=\"docstring\">`a ++ b` is the result of concatenation of `a` and `b`, usually read \"append\".\nThe meaning of this notation is type-dependent. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `++` in identifiers is `append`.</code>","403":"<code>SameContents tail✝ xs' → SameContents ys ys' → SameContents (tail✝ ++ ys) (xs' ++ ys')</code>","404":"<code>SameContents.filter.{u_1} {α✝ : Type u_1} {xs ys : List α✝} {p : α✝ → Bool} :\n  SameContents xs ys → SameContents (List.filter p xs) (List.filter p ys)</code><span class=\"sep\"></span><code class=\"docstring\">If two lists have the same contents, then removing the same elements results in them still having\nthe same contents\\.\n</code>","405":"<code>List ?m.11</code>","406":"<code>List.filter.{u} {α : Type u} (p : α → Bool) (l : List α) : List α</code><span class=\"sep\"></span><code class=\"docstring\">Returns the list of elements in `l` for which `p` returns `true`.\n\n`O(|l|)`.\n\nExamples:\n* `[1, 2, 5, 2, 7, 7].filter (· &gt; 2) = [5, 7, 7]`\n* `[1, 2, 5, 2, 7, 7].filter (fun _ =&gt; false) = []`\n* `[1, 2, 5, 2, 7, 7].filter (fun _ =&gt; true) = [1, 2, 5, 2, 7, 7]`\n</code>","407":"<code>?m.11 → Bool</code>","408":"<code>α✝ → Bool</code>","409":"<code class=\"docstring\">The `fun_induction` tactic is a convenience wrapper around the `induction` tactic to use the the\nfunctional induction principle.\n\nThe tactic invocation\n```\nfun_induction f x₁ ... xₙ y₁ ... yₘ\n```\nwhere `f` is a function defined by non-mutual structural or well-founded recursion, is equivalent to\n```\ninduction y₁, ... yₘ using f.induct_unfolding x₁ ... xₙ\n```\nwhere the arguments of `f` are used as arguments to `f.induct_unfolding` or targets of the\ninduction, as appropriate.\n\nThe form\n```\nfun_induction f\n```\n(with no arguments to `f`) searches the goal for a unique eligible application of `f`, and uses\nthese arguments. An application of `f` is eligible if it is saturated and the arguments that will\nbecome targets are free variables.\n\nThe forms `fun_induction f x y generalizing z₁ ... zₙ` and\n`fun_induction f x y with | case1 =&gt; tac₁ | case2 x' ih =&gt; tac₂` work like with `induction.`\n\nUnder `set_option tactic.fun_induction.unfolding true` (the default), `fun_induction` uses the\n`f.induct_unfolding` induction principle, which will try to automatically unfold the call to `f` in\nthe goal. With `set_option tactic.fun_induction.unfolding false`, it uses `f.induct` instead.\n</code>","41":"<code>LeanW26.Simple.h₂ (g : A → A) (y : A) : A</code>","410":"<code>∀ (x : α✝), x ∈ [] → x ∈ ys</code>","411":"<code>∀ (y : α✝), y ∈ ys → y ∈ []</code>","412":"<code>p a✝ = true</code>","413":"<code>(∀ (x : α✝), x ∈ as✝ → x ∈ ys) → (∀ (y : α✝), y ∈ ys → y ∈ as✝) → SameContents (List.filter p as✝) (List.filter p ys)</code>","414":"<code>∀ (x : α✝), x ∈ a✝ :: as✝ → x ∈ ys</code>","415":"<code>∀ (y : α✝), y ∈ ys → y ∈ a✝ :: as✝</code>","416":"<code>p a✝ = false</code>","417":"<code>ListSet.{u_1} (α : Type u_1) : Type u_1</code>","418":"<code>Quotient.{u} {α : Sort u} (s : Setoid α) : Sort u</code><span class=\"sep\"></span><code class=\"docstring\">Quotient types coarsen the propositional equality for a type so that terms related by some\nequivalence relation are considered equal. The equivalence relation is given by an instance of\n`Setoid`.\n\nSet-theoretically, `Quotient s` can seen as the set of equivalence classes of `α` modulo the\n`Setoid` instance's relation `s.r`. Functions from `Quotient s` must prove that they respect `s.r`:\nto define a function `f : Quotient s → β`, it is necessary to provide `f' : α → β` and prove that\nfor all `x : α` and `y : α`, `s.r x y → f' x = f' y`. `Quotient.lift` implements this operation.\n\nThe key quotient operators are:\n * `Quotient.mk` places elements of the underlying type `α` into the quotient.\n * `Quotient.lift` allows the definition of functions from the quotient to some other type.\n * `Quotient.sound` asserts the equality of elements related by `r`\n * `Quotient.ind` is used to write proofs about quotients by assuming that all elements are\n   constructed with `Quotient.mk`.\n\n`Quotient` is built on top of the primitive quotient type `Quot`, which does not require a proof\nthat the relation is an equivalence relation. `Quotient` should be used instead of `Quot` for\nrelations that actually are equivalence relations.\n</code>","419":"<code>ListSet.mk.{u_1} {α : Type u_1} (xs : List α) : ListSet α</code>","42":"<code>LeanW26.Simple.α : Type 1</code>","420":"<code>Quotient.mk.{u} {α : Sort u} (s : Setoid α) (a : α) : Quotient s</code><span class=\"sep\"></span><code class=\"docstring\">Places an element of a type into the quotient that equates terms according to an equivalence\nrelation.\n\nThe setoid instance is provided explicitly. `Quotient.mk'` uses instance synthesis instead.\n\nGiven `v : α`, `Quotient.mk s v : Quotient s` is like `v`, except all observations of `v`'s value\nmust respect `s.r`. `Quotient.lift` allows values in a quotient to be mapped to other types, so long\nas the mapping respects `s.r`.\n</code>","421":"<code>SameContents.setoid_eq_SameContents.{u_1} {α : Type u_1} (xs ys : List α) :\n  have x := setoid;\n  (xs ≈ ys) = SameContents xs ys</code>","422":"<code>Setoid (List α)</code>","423":"<code>HasEquiv.Equiv.{u, v} {α : Sort u} [self : HasEquiv α] : α → α → Sort v</code><span class=\"sep\"></span><code class=\"docstring\">`x ≈ y` says that `x` and `y` are equivalent. Because this is a typeclass,\nthe notion of equivalence is type-dependent. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `≈` in identifiers is `equiv`.</code>","424":"<code>ListSet.sound.{u_1} {α : Type u_1} {xs ys : List α} : SameContents xs ys → mk xs = mk ys</code>","425":"<code>SameContents xs ys</code>","426":"<code>Quotient.sound.{u} {α : Sort u} {s : Setoid α} {a b : α} : a ≈ b → Quotient.mk s a = Quotient.mk s b</code><span class=\"sep\"></span><code class=\"docstring\">The **quotient axiom**, which asserts the equality of elements related in the setoid.\n\nBecause `Quotient` is built on a lower-level type `Quot`, `Quotient.sound` is implemented as a\ntheorem. It is derived from `Quot.sound`, the soundness axiom for the lower-level quotient type\n`Quot`.\n</code>","427":"<code>Quotient.liftOnBeta.{u_1, u_2} {α : Sort u_1} {β : Sort u_2} {s : Setoid α} {x : α} {f : α → β}\n  {p : ∀ (a b : α), a ≈ b → f a = f b} : (Quotient.mk s x).liftOn f p = f x</code>","428":"<code>α → β</code>","429":"<code>Sort u_2</code>","43":"<code>LeanW26.Simple.c₀ (f : α → α) (x : α) : α</code>","430":"<code>∀ (a b : α), a ≈ b → f a = f b</code>","431":"<code>Setoid α</code>","432":"<code>Quotient.liftOn.{u, v} {α : Sort u} {β : Sort v} {s : Setoid α} (q : Quotient s) (f : α → β)\n  (c : ∀ (a b : α), a ≈ b → f a = f b) : β</code><span class=\"sep\"></span><code class=\"docstring\">Lifts a function from an underlying type to a function on a quotient, requiring that it respects the\nquotient's equivalence relation.\n\nGiven `s : Setoid α` and a quotient value `q : Quotient s`, applying a function `f : α → β` requires\na proof `c` that `f` respects the equivalence relation `s.r`. In this case, the term\n`Quotient.liftOn q f h : β` reduces to the result of applying `f` to the underlying `α` value.\n\n`Quotient.lift` is a version of this operation that takes the quotient value last, rather than\nfirst.\n</code>","433":"<code class=\"docstring\">A specific universe in Lean's infinite hierarchy of universes. </code>","434":"<code>ListSet.liftOnBeta.{u_1, u_2} {α : Type u_1} {β : Sort u_2} {xs : List α} {f : List α → β}\n  {p : ∀ (a b : List α), a ≈ b → f a = f b} : Quotient.liftOn (mk xs) f p = f xs</code>","435":"<code>List α → β</code>","436":"<code>∀ (a b : List α), a ≈ b → f a = f b</code>","437":"<code>Quotient.liftOn₂beta.{u_1, u_2, u_3} {α : Sort u_1} {β : Sort u_2} {γ : Sort u_3} {s : Setoid α} {s' : Setoid β} {x : α}\n  {y : β} {f : α → β → γ} {p : ∀ (a₁ : α) (b₁ : β) (a₂ : α) (b₂ : β), a₁ ≈ a₂ → b₁ ≈ b₂ → f a₁ b₁ = f a₂ b₂} :\n  (Quotient.mk s x).liftOn₂ (Quotient.mk s' y) f p = f x y</code>","438":"<code>β</code>","439":"<code>α → β → γ</code>","44":"<code>α → α</code>","440":"<code>Sort u_3</code>","441":"<code>∀ (a₁ : α) (b₁ : β) (a₂ : α) (b₂ : β), a₁ ≈ a₂ → b₁ ≈ b₂ → f a₁ b₁ = f a₂ b₂</code>","442":"<code>Quotient.liftOn₂.{uA, uB, uC} {α : Sort uA} {β : Sort uB} {φ : Sort uC} {s₁ : Setoid α} {s₂ : Setoid β}\n  (q₁ : Quotient s₁) (q₂ : Quotient s₂) (f : α → β → φ)\n  (c : ∀ (a₁ : α) (b₁ : β) (a₂ : α) (b₂ : β), a₁ ≈ a₂ → b₁ ≈ b₂ → f a₁ b₁ = f a₂ b₂) : φ</code><span class=\"sep\"></span><code class=\"docstring\">Lifts a binary function from the underlying types to a binary function on quotients. The function\nmust respect both quotients' equivalence relations.\n\n`Quotient.liftOn` is a version of this operation for unary functions. `Quotient.lift₂` is a version\nthat take the quotient parameters last.\n</code>","443":"<code>Setoid β</code>","444":"<code>Quotient.lift₂.{uA, uB, uC} {α : Sort uA} {β : Sort uB} {φ : Sort uC} {s₁ : Setoid α} {s₂ : Setoid β} (f : α → β → φ)\n  (c : ∀ (a₁ : α) (b₁ : β) (a₂ : α) (b₂ : β), a₁ ≈ a₂ → b₁ ≈ b₂ → f a₁ b₁ = f a₂ b₂) (q₁ : Quotient s₁)\n  (q₂ : Quotient s₂) : φ</code><span class=\"sep\"></span><code class=\"docstring\">Lifts a binary function from the underlying types to a binary function on quotients. The function\nmust respect both quotients' equivalence relations.\n\n`Quotient.lift` is a version of this operation for unary functions. `Quotient.liftOn₂` is a version\nthat take the quotient parameters first.\n</code>","445":"<code>Quotient.lift.{u, v} {α : Sort u} {β : Sort v} {s : Setoid α} (f : α → β) :\n  (∀ (a b : α), a ≈ b → f a = f b) → Quotient s → β</code><span class=\"sep\"></span><code class=\"docstring\">Lifts a function from an underlying type to a function on a quotient, requiring that it respects the\nquotient's equivalence relation.\n\nGiven `s : Setoid α` and a quotient `Quotient s`, applying a function `f : α → β` requires a proof\n`h` that `f` respects the equivalence relation `s.r`. In this case, the function\n`Quotient.lift f h : Quotient s → β` computes the same values as `f`.\n\n`Quotient.liftOn` is a version of this operation that takes the quotient value as its first explicit\nparameter.\n</code>","446":"<code>ListSet.liftOn₂beta.{u_1, u_2, u_3} {α : Type u_1} {β : Type u_2} {γ : Sort u_3} {xs : List α} {ys : List β}\n  {f : List α → List β → γ}\n  {p : ∀ (a₁ : List α) (b₁ : List β) (a₂ : List α) (b₂ : List β), a₁ ≈ a₂ → b₁ ≈ b₂ → f a₁ b₁ = f a₂ b₂} :\n  Quotient.liftOn₂ (mk xs) (mk ys) f p = f xs ys</code>","447":"<code>List β</code>","448":"<code>Type u_2</code>","449":"<code>List α → List β → γ</code>","45":"<code>α</code>","450":"<code>∀ (a₁ : List α) (b₁ : List β) (a₂ : List α) (b₂ : List β), a₁ ≈ a₂ → b₁ ≈ b₂ → f a₁ b₁ = f a₂ b₂</code>","451":"<code>ListSet α</code>","452":"<code>ListSet.contains.{u_1} {α : Type u_1} [DecidableEq α] (xs : ListSet α) (x : α) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Checks whether `x` is found in `xs`\n</code>","453":"<code>DecidableEq.{u} (α : Sort u) : Sort (max 1 u)</code><span class=\"sep\"></span><code class=\"docstring\">Propositional equality is `Decidable` for all elements of a type.\n\nIn other words, an instance of `DecidableEq α` is a means of deciding the proposition `a = b` is\nfor all `a b : α`.\n</code>","454":"<code>Type ?u.18539</code>","455":"<code>DecidableEq α</code>","456":"<code>∀ (x : α), x ∈ a✝ → x ∈ b✝</code>","457":"<code>∀ (y : α), y ∈ b✝ → y ∈ a✝</code>","458":"<code>ListSet.insert.{u_1} {α : Type u_1} (xs : ListSet α) (x : α) : ListSet α</code><span class=\"sep\"></span><code class=\"docstring\">Inserts `x` into `xs`\\.\n</code>","459":"<code>Type ?u.19464</code>","46":"<code>LeanW26.Simple.c₁ (f : α → α) (x : α) : α</code>","460":"<code>ListSet.insert_contains.{u_1} {α : Type u_1} {x : α} {x✝ : DecidableEq α} {xs : ListSet α} :\n  (xs.insert x).contains x = true</code>","461":"<code>Quotient.ind.{u} {α : Sort u} {s : Setoid α} {motive : Quotient s → Prop} :\n  (∀ (a : α), motive (Quotient.mk s a)) → ∀ (q : Quotient s), motive q</code><span class=\"sep\"></span><code class=\"docstring\">A reasoning principle for quotients that allows proofs about quotients to assume that all values are\nconstructed with `Quotient.mk`.\n</code>","462":"<code>ListSet.union.{u_1} {α : Type u_1} (xs ys : ListSet α) : ListSet α</code>","463":"<code>Type ?u.24914</code>","464":"<code>ListSet.union_contains.{u_1} {α : Type u_1} {x : α} {x✝ : DecidableEq α} {xs ys : ListSet α} :\n  ((xs.union ys).contains x = true) = (xs.contains x = true ∨ ys.contains x = true)</code><span class=\"sep\"></span><code class=\"docstring\">The following are equivalent:\n\n* $x \\in A \\cup B$\n\n* $x \\in A \\vee x \\in B$\n  </code>","465":"<code>Or (a b : Prop) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">`Or a b`, or `a ∨ b`, is the disjunction of propositions. There are two\nconstructors for `Or`, called `Or.inl : a → a ∨ b` and `Or.inr : b → a ∨ b`,\nand you can use `match` or `cases` to destruct an `Or` assumption into the\ntwo cases.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `∨` in identifiers is `or`.\n\n * The recommended spelling of `\\/` in identifiers is `or` (prefer `∨` over `\\/`).</code>","466":"<code>Quotient.ind₂.{uA, uB} {α : Sort uA} {β : Sort uB} {s₁ : Setoid α} {s₂ : Setoid β}\n  {motive : Quotient s₁ → Quotient s₂ → Prop} (h : ∀ (a : α) (b : β), motive (Quotient.mk s₁ a) (Quotient.mk s₂ b))\n  (q₁ : Quotient s₁) (q₂ : Quotient s₂) : motive q₁ q₂</code>","467":"<code>ListSet.Mem.{u_1} {α : Type u_1} (xs : ListSet α) (x : α) : Prop</code>","468":"<code>Type ?u.32106</code>","469":"<code>Membership.{u, v} (α : outParam (Type u)) (γ : Type v) : Type (max u v)</code><span class=\"sep\"></span><code class=\"docstring\">The typeclass behind the notation `a ∈ s : Prop` where `a : α`, `s : γ`.\nBecause `α` is an `outParam`, the \"container type\" `γ` determines the type\nof the elements of the container.\n</code>","47":"<code>LeanW26.Simple.c₂ (f : α → α) (x : α) : α</code>","470":"<code>ListSet α → α → Prop</code><span class=\"sep\"></span><code class=\"docstring\">The membership relation `a ∈ s : Prop` where `a : α`, `s : γ`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `∈` in identifiers is `mem`.</code>","471":"<code>ListSet.mem_eq_contains.{u_1} {α : Type u_1} {x : α} {x✝ : DecidableEq α} {xs : ListSet α} :\n  (xs.contains x = true) = (x ∈ xs)</code><span class=\"sep\"></span><code class=\"docstring\">The containment test is equivalent to the membership predicate\\.\n</code>","472":"<code>ListSet.minus.{u_1} {α : Type u_1} [DecidableEq α] (xs ys : ListSet α) : ListSet α</code>","473":"<code>Type ?u.36871</code>","474":"<code>Not (a : Prop) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">`Not p`, or `¬p`, is the negation of `p`. It is defined to be `p → False`,\nso if your goal is `¬p` you can use `intro h` to turn the goal into\n`h : p ⊢ False`, and if you have `hn : ¬p` and `h : p` then `hn h : False`\nand `(hn h).elim` will prove anything.\nFor more information: [Propositional Logic](https://lean-lang.org/theorem_proving_in_lean4/propositions_and_proofs.html#propositional-logic)\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `¬` in identifiers is `not`.</code>","475":"<code>ListSet.intersection.{u_1} {α : Type u_1} [DecidableEq α] (xs ys : ListSet α) : ListSet α</code>","476":"<code>Type ?u.42030</code>","477":"<code>ListSet.intersection_commutative.{u_1} {α : Type u_1} {x✝ : DecidableEq α} {xs ys : ListSet α} :\n  xs.intersection ys = ys.intersection xs</code>","48":"<code>LeanW26.Simple.c₃ (f : α → α) (x : α) : α</code>","49":"<code>LeanW26.Simple.N : Type 1</code>","5":"<code class=\"docstring\">The universe level 100</code>","50":"<code>LeanW26.Simple.succ (m : N) (f : α → α) (x : α) : α</code>","51":"<code>N</code>","52":"<code>LeanW26.Simple.add (m n : N) (f : α → α) (x : α) : α</code>","53":"<code>LeanW26.Simple.mul (m n : N) (f : α → α) (x : α) : α</code>","54":"<code>LeanW26.Simple.ifzero (m n p : N) (f : α → α) (x : α) : α</code>","55":"<code>LeanW26.Simple.one_plus_one_is_two : add c₁ c₁ = c₂</code>","56":"<code>rfl.{u} {α : Sort u} {a : α} : a = a</code><span class=\"sep\"></span><code class=\"docstring\">`rfl : a = a` is the unique constructor of the equality type. This is the\nsame as `Eq.refl` except that it takes `a` implicitly instead of explicitly.\n\nThis is a more powerful theorem than it may appear at first, because although\nthe statement of the theorem is `a = a`, Lean will allow anything that is\ndefinitionally equal to that type. So, for instance, `2 + 2 = 4` is proven in\nLean by `rfl`, because both sides are the same up to definitional equality.\n</code>","57":"<code>?m.1</code>","58":"<code>?m.3 x</code>","59":"<code>?m.3 x✝</code>","6":"<code class=\"docstring\">Declares one or more universe variables.\n\n`universe u v`\n\n`Prop`, `Type`, `Type u` and `Sort u` are types that classify other types, also known as\n*universes*. In `Type u` and `Sort u`, the variable `u` stands for the universe's *level*, and a\nuniverse at level `u` can only classify universes that are at levels lower than `u`. For more\ndetails on type universes, please refer to [the relevant chapter of Theorem Proving in Lean][tpil\nuniverses].\n\nJust as type arguments allow polymorphic definitions to be used at many different types, universe\nparameters, represented by universe variables, allow a definition to be used at any required level.\nWhile Lean mostly handles universe levels automatically, declaring them explicitly can provide more\ncontrol when writing signatures. The `universe` keyword allows the declared universe variables to be\nused in a collection of definitions, and Lean will ensure that these definitions use them\nconsistently.\n\n[tpil universes]: https://lean-lang.org/theorem_proving_in_lean4/dependent_type_theory.html#types-as-objects\n(Type universes on Theorem Proving in Lean)\n\n```lean\n/- Explicit type-universe parameter. -/\ndef id₁.{u} (α : Type u) (a : α) := a\n\n/- Implicit type-universe parameter, equivalent to `id₁`.\n  Requires option `autoImplicit true`, which is the default. -/\ndef id₂ (α : Type u) (a : α) := a\n\n/- Explicit standalone universe variable declaration, equivalent to `id₁` and `id₂`. -/\nuniverse u\ndef id₃ (α : Type u) (a : α) := a\n```\n\nOn a more technical note, using a universe variable only in the right-hand side of a definition\ncauses an error if the universe has not been declared previously.\n\n```lean\ndef L₁.{u} := List (Type u)\n\n-- def L₂ := List (Type u) -- error: `unknown universe level 'u'`\n\nuniverse u\ndef L₃ := List (Type u)\n```\n\n## Examples\n\n```lean\nuniverse u v w\n\nstructure Pair (α : Type u) (β : Type v) : Type (max u v) where\n  a : α\n  b : β\n\n#check Pair.{v, w}\n-- Pair : Type v → Type w → Type (max v w)\n```\n</code>","60":"<code>?m.5 g</code>","61":"<code>p</code>","62":"<code>p → q</code>","63":"<code>LeanW26.NonSimpleTypes.id1.{u} (α : Type u) : α → α</code>","64":"<code>x✝</code>","65":"<code>LeanW26.NonSimpleTypes.id2.{u} {α : Type u} : α → α</code>","66":"<code>α✝</code>","67":"<code>LeanW26.NonSimpleTypes.id3.{u} {α : Type u} (x : α) : α</code>","68":"<code>LeanW26.NonSimpleTypes.id4.{u} (α : Type u) : α → α</code>","69":"<code>LeanW26.NonSimpleTypes.id5.{u_1} (α : Sort u_1) : α → α</code>","7":"<code>LeanW26.Universes.f1.{u} (x : Type u) : Type u</code>","70":"<code>Sort u_1</code>","71":"<code class=\"docstring\">In Lean, every concrete type other than the universes\nand every type constructor other than dependent arrows\nis an instance of a general family of type constructions known as inductive types.\nIt is remarkable that it is possible to construct a substantial edifice of mathematics\nbased on nothing more than the type universes, dependent arrow types, and inductive types;\neverything else follows from those.\nIntuitively, an inductive type is built up from a specified list of constructors.\nFor example, `List α` is the list of elements of type `α`, and is defined as follows:\n```\ninductive List (α : Type u) where\n| nil\n| cons (head : α) (tail : List α)\n```\nA list of elements of type `α` is either the empty list, `nil`,\nor an element `head : α` followed by a list `tail : List α`.\nSee [Inductive types](https://lean-lang.org/theorem_proving_in_lean4/inductive_types.html)\nfor more information.\n</code>","72":"<code>LeanW26.NonSimpleTypes.MyList {α : Type} : Type</code>","73":"<code>LeanW26.NonSimpleTypes.MyList.nil {α : Type} : MyList</code>","74":"<code>LeanW26.NonSimpleTypes.MyList.cons {α : Type} : α → MyList → MyList</code>","75":"<code>LeanW26.NonSimpleTypes.Vec.{u} (α : Type u) : ℕ → Type u</code>","76":"<code>LeanW26.NonSimpleTypes.Vec.nil.{u} {α : Type u} : Vec α 0</code>","77":"<code>LeanW26.NonSimpleTypes.Vec.cons.{u} {α : Type u} {n : ℕ} : α → Vec α n → Vec α (n + 1)</code>","78":"<code>LeanW26.NonSimpleTypes.Vec.add.{u} {α : Type u} [Add α] {n : ℕ} (x y : Vec α n) : Vec α n</code>","79":"<code>Add.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">The homogeneous version of `HAdd`: `a + b : α` where `a b : α`. </code>","8":"<code>Type u</code>","80":"<code>Vec α n</code>","81":"<code class=\"docstring\">Pattern matching. `match e, ... with | p, ... =&gt; f | ...` matches each given\nterm `e` against each pattern `p` of a match alternative. When all patterns\nof an alternative match, the `match` term evaluates to the value of the\ncorresponding right-hand side `f` with the pattern variables bound to the\nrespective matched values.\nIf used as `match h : e, ... with | p, ... =&gt; f | ...`, `h : e = p` is available\nwithin `f`.\n\nWhen not constructing a proof, `match` does not automatically substitute variables\nmatched on in dependent variables' types. Use `match (generalizing := true) ...` to\nenforce this.\n\nSyntax quotations can also be used in a pattern match.\nThis matches a `Syntax` value against quotations, pattern variables, or `_`.\n\nQuoted identifiers only match identical identifiers - custom matching such as by the preresolved\nnames only should be done explicitly.\n\n`Syntax.atom`s are ignored during matching by default except when part of a built-in literal.\nFor users introducing new atoms, we recommend wrapping them in dedicated syntax kinds if they\nshould participate in matching.\nFor example, in\n```lean\nsyntax \"c\" (\"foo\" &lt;|&gt; \"bar\") ...\n```\n`foo` and `bar` are indistinguishable during matching, but in\n```lean\nsyntax foo := \"foo\"\nsyntax \"c\" (foo &lt;|&gt; \"bar\") ...\n```\nthey are not.\n</code>","82":"<code>Vec α n✝</code>","83":"<code>LeanW26.NonSimpleTypes.chooseType : Bool → Type</code>","84":"<code>Bool : Type</code><span class=\"sep\"></span><code class=\"docstring\">The Boolean values, `true` and `false`.\n\nLogically speaking, this is equivalent to `Prop` (the type of propositions). The distinction is\npublic important for programming: both propositions and their proofs are erased in the code generator,\nwhile `Bool` corresponds to the Boolean type in most programming languages and carries precisely one\nbit of run-time information.\n</code>","85":"<code>Bool.true : Bool</code><span class=\"sep\"></span><code class=\"docstring\">The Boolean value `true`, not to be confused with the proposition `True`. </code>","86":"<code>Bool.false : Bool</code><span class=\"sep\"></span><code class=\"docstring\">The Boolean value `false`, not to be confused with the proposition `False`. </code>","87":"<code>Sigma.mk.{u, v} {α : Type u} {β : α → Type v} (fst : α) (snd : β fst) : Sigma β</code><span class=\"sep\"></span><code class=\"docstring\">Constructs a dependent pair.\n\nUsing this constructor in a context in which the type is not known usually requires a type\nascription to determine `β`. This is because the desired relationship between the two values can't\ngenerally be determined automatically.\n</code>","88":"<code>LeanW26.NonSimpleTypes.Vec.default (n : ℕ) : (n : ℕ) × Vec ℕ n</code>","89":"<code class=\"docstring\">`let` is used to declare a local definition. Example:\n```\nlet x := 1\nlet y := x + 1\nx + y\n```\nSince functions are first class citizens in Lean, you can use `let` to declare\nlocal functions too.\n```\nlet double := fun x =&gt; 2*x\ndouble (double 3)\n```\nFor recursive definitions, you should use `let rec`.\nYou can also perform pattern matching using `let`. For example,\nassume `p` has type `Nat × Nat`, then you can write\n```\nlet (x, y) := p\nx + y\n```\n\nThe *anaphoric let* `let := v` defines a variable called `this`.\n</code>","9":"<code class=\"docstring\">The universe parameter u</code>","90":"<code>(n : ℕ) × Vec ℕ n</code>","91":"<code>Sigma.fst.{u, v} {α : Type u} {β : α → Type v} (self : Sigma β) : α</code><span class=\"sep\"></span><code class=\"docstring\">The first component of a dependent pair.\n</code>","92":"<code>Sigma.snd.{u, v} {α : Type u} {β : α → Type v} (self : Sigma β) : β self.fst</code><span class=\"sep\"></span><code class=\"docstring\">The second component of a dependent pair. Its type depends on the first component.\n</code>","93":"<code>LeanW26.LambdaCalculus.f1 (x : ℕ) : ℕ</code>","94":"<code>LeanW26.LambdaCalculus.g1 (x y : ℕ) : ℕ</code>","95":"<code>LeanW26.LambdaCalculus.f2 (x : ℕ) : ℕ</code>","96":"<code>LeanW26.LambdaCalculus.g2 (x y : ℕ) : ℕ</code>","97":"<code>LeanW26.LambdaCalculus.f3 : ℕ → ℕ</code>","98":"<code>LeanW26.LambdaCalculus.g3 : ℕ → ℕ → ℕ</code>","99":"<code>LeanW26.Monads.Maybe.{u} (α : Type u) : Type u</code>"}