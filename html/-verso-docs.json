{"0":"<code class=\"docstring\">`namespace &lt;id&gt;` opens a section with label `&lt;id&gt;` that influences naming and name resolution inside\nthe section:\n* Declarations names are prefixed: `def seventeen : ℕ := 17` inside a namespace `Nat` is given the\n  full name `Nat.seventeen`.\n* Names introduced by `export` declarations are also prefixed by the identifier.\n* All names starting with `&lt;id&gt;.` become available in the namespace without the prefix. These names\n  are preferred over names introduced by outer namespaces or `open`.\n* Within a namespace, declarations can be `protected`, which excludes them from the effects of\n  opening the namespace.\n\nAs with `section`, namespaces can be nested and the scope of a namespace is terminated by a\ncorresponding `end &lt;id&gt;` or the end of the file.\n\n`namespace` also acts like `section` in delimiting the scope of `variable`, `open`, and other scoped commands.\n</code>","1":"<code class=\"docstring\">The universe of propositions. `Prop ≡ Sort 0`.\n\nEvery proposition is propositionally equal to either `True` or `False`. </code>","10":"<code>LeanW26.Universes.f2.{w} (x : Type w) : Type w</code>","100":"<code>LeanW26.f2 (x : ℕ) : ℕ</code>","101":"<code class=\"docstring\">`if c then t else e` is notation for `ite c t e`, \"if-then-else\", which decides to\nreturn `t` or `e` depending on whether `c` is true or false. The explicit argument\n`c : Prop` does not have any actual computational content, but there is an additional\n`[Decidable c]` argument synthesized by typeclass inference which actually\ndetermines how to evaluate `c` to true or false. Write `if h : c then t else e`\ninstead for a \"dependent if-then-else\" `dite`, which allows `t`/`e` to use the fact\nthat `c` is true/false.\n</code>","102":"<code>Even.{u_2} {α : Type u_2} [Add α] (a : α) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">An element `a` of a type `α` with addition satisfies `Even a` if `a = r + r`,\nfor some `r : α`. </code>","103":"<code>LeanW26.f3 (x : ℕ) : ℕ</code>","104":"<code>LeanW26.do_twice (f : ℕ → ℕ) (x : ℕ) : ℕ</code>","105":"<code>ℕ → ℕ</code>","106":"<code>LeanW26.h1 (x : ℕ) : ℕ</code>","107":"<code>LeanW26.h2 : ℕ → ℕ</code>","108":"<code>LeanW26.h3 : ℕ → ℕ</code>","109":"<code>LeanW26.nonzero (x : ℕ) : Bool</code>","11":"<code>Type w</code>","110":"<code>Nat.zero : ℕ</code><span class=\"sep\"></span><code class=\"docstring\">Zero, the smallest natural number.\n\nUsing `Nat.zero` explicitly should usually be avoided in favor of the literal `0`, which is the\n[simp normal form](https://lean-lang.org/doc/reference/4.26.0-rc2/find/?domain=Verso.Genre.Manual.section&name=simp-normal-forms).\n</code>","111":"<code>Nat.succ (n : ℕ) : ℕ</code><span class=\"sep\"></span><code class=\"docstring\">The successor of a natural number `n`.\n\nUsing `Nat.succ n` should usually be avoided in favor of `n + 1`, which is the [simp normal\nform](https://lean-lang.org/doc/reference/4.26.0-rc2/find/?domain=Verso.Genre.Manual.section&name=simp-normal-forms).\n</code>","112":"<code>LeanW26.nonzero' (x : ℕ) : Prop</code>","113":"<code>LeanW26.is_3_or_12 (x : ℕ) : Bool</code>","114":"<code>LeanW26.is_3_and_12 (x y : ℕ) : Bool</code>","115":"<code>LeanW26.fct (n : ℕ) : ℕ</code>","116":"<code>LeanW26.do_n (n : ℕ) (f : ℕ → ℕ) (x : ℕ) : ℕ</code>","117":"<code>LeanW26.f10 (x : ℕ) : ℕ</code>","118":"<code>LeanW26.factAux (n acc : ℕ) : ℕ</code>","119":"<code>LeanW26.fact (n : ℕ) : ℕ</code>","12":"<code class=\"docstring\">The universe parameter w</code>","120":"<code>LeanW26.fact2 (n : ℕ) : ℕ</code>","121":"<code>LeanW26.fact2.aux (n acc : ℕ) : ℕ</code>","122":"<code>LeanW26.helper (n acc : ℕ) : factAux n acc = acc * fct n</code>","123":"<code class=\"docstring\">`by tac` constructs a term of the expected type by running the tactic(s) `tac`. </code>","124":"<code>Eq.{u_1} {α : Sort u_1} : α → α → Prop</code><span class=\"sep\"></span><code class=\"docstring\">The equality relation. It has one introduction rule, `Eq.refl`.\nWe use `a = b` as notation for `Eq a b`.\nA fundamental property of equality is that it is an equivalence relation.\n```\nvariable (α : Type) (a b c d : α)\nvariable (hab : a = b) (hcb : c = b) (hcd : c = d)\n\nexample : a = d :=\n  Eq.trans (Eq.trans hab (Eq.symm hcb)) hcd\n```\nEquality is much more than an equivalence relation, however. It has the important property that every assertion\nrespects the equivalence, in the sense that we can substitute equal expressions without changing the truth value.\nThat is, given `h1 : a = b` and `h2 : p a`, we can construct a proof for `p b` using substitution: `Eq.subst h1 h2`.\nExample:\n```\nexample (α : Type) (a b : α) (p : α → Prop)\n        (h1 : a = b) (h2 : p a) : p b :=\n  Eq.subst h1 h2\n\nexample (α : Type) (a b : α) (p : α → Prop)\n    (h1 : a = b) (h2 : p a) : p b :=\n  h1 ▸ h2\n```\nThe triangle in the second presentation is a macro built on top of `Eq.subst` and `Eq.symm`, and you can enter it by typing `\\t`.\nFor more information: [Equality](https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `=` in identifiers is `eq`.</code>","125":"<code>HMul.hMul.{u, v, w} {α : Type u} {β : Type v} {γ : outParam (Type w)} [self : HMul α β γ] : α → β → γ</code><span class=\"sep\"></span><code class=\"docstring\">`a * b` computes the product of `a` and `b`.\nThe meaning of this notation is type-dependent. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `*` in identifiers is `mul`.</code>","126":"<code class=\"docstring\">Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a term whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context,\n  generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero =&gt; tac₁ | succ x' ih =&gt; tac₂`\n  uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n</code>","127":"<code class=\"docstring\">After `with`, there is an optional tactic that runs on all branches, and\nthen a list of alternatives.\n</code>","128":"<code class=\"docstring\">The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or\nnon-dependent hypotheses. It has many variants:\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [h₁, h₂, ..., hₙ]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]` and the given `hᵢ`'s, where the `hᵢ`'s are expressions.-\n- If an `hᵢ` is a defined constant `f`, then `f` is unfolded. If `f` has equational lemmas associated\n  with it (and is not a projection or a `reducible` definition), these are used to rewrite with `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the\n  attribute `[simp]` and all hypotheses.\n- `simp only [h₁, h₂, ..., hₙ]` is like `simp [h₁, h₂, ..., hₙ]` but does not use `[simp]` lemmas.\n- `simp [-id₁, ..., -idₙ]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]`, but removes the ones named `idᵢ`.\n- `simp at h₁ h₂ ... hₙ` simplifies the hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. If\n  the target or another hypothesis depends on `hᵢ`, a new simplified hypothesis\n  `hᵢ` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the\n  other hypotheses.\n</code>","129":"<code>∀ (acc : ℕ), factAux k acc = acc * fct k</code>","13":"<code>Nat : Type</code><span class=\"sep\"></span><code class=\"docstring\">The natural numbers, starting at zero.\n\nThis type is special-cased by both the kernel and the compiler, and overridden with an efficient\nimplementation. Both use a fast arbitrary-precision arithmetic library (usually\n[GMP](https://gmplib.org/)); at runtime, `Nat` values that are sufficiently small are unboxed.\n</code>","130":"<code>HAdd.hAdd.{u, v, w} {α : Type u} {β : Type v} {γ : outParam (Type w)} [self : HAdd α β γ] : α → β → γ</code><span class=\"sep\"></span><code class=\"docstring\">`a + b` computes the sum of `a` and `b`.\nThe meaning of this notation is type-dependent. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `+` in identifiers is `add`.</code>","131":"<code class=\"docstring\">* `unfold id` unfolds all occurrences of definition `id` in the target.\n* `unfold id1 id2 ...` is equivalent to `unfold id1; unfold id2; ...`.\n* `unfold id at h` unfolds at the hypothesis `h`.\n\nDefinitions can be either global or local definitions.\n\nFor non-recursive global definitions, this tactic is identical to `delta`.\nFor recursive global definitions, it uses the \"unfolding lemma\" `id.eq_def`,\nwhich is generated for each recursive definition, to unfold according to the recursive definition given by the user.\nOnly one level of unfolding is performed, in contrast to `simp only [id]`, which unfolds definition `id` recursively.\n</code>","132":"<code class=\"docstring\">`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n</code>","133":"<code class=\"docstring\">`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n</code>","134":"<code>Nat.mul_assoc (n m k : ℕ) : n * m * k = n * (m * k)</code>","135":"<code>LeanW26.fct_fact : fact = fct</code>","136":"<code class=\"docstring\">Apply function extensionality and introduce new hypotheses.\nThe tactic `funext` will keep applying the `funext` lemma until the goal target is not reducible to\n```\n  |-  ((fun x =&gt; ...) = (fun x =&gt; ...))\n```\nThe variant `funext h₁ ... hₙ` applies `funext` `n` times, and uses the given identifiers to name the new hypotheses.\nPatterns can be used like in the `intro` tactic. Example, given a goal\n```\n  |-  ((fun x : Nat × Bool =&gt; ...) = (fun x =&gt; ...))\n```\n`funext (a, b)` applies `funext` once and performs pattern matching on the newly introduced pair.\n</code>","137":"<code>LeanW26.is_even (x : ℕ) : Bool</code>","138":"<code>LeanW26.my_prop : Prop</code>","139":"<code>LeanW26.my_proof : my_prop</code>","14":"<code>List.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">Linked lists: ordered lists, in which each element has a reference to the next element.\n\nMost operations on linked lists take time proportional to the length of the list, because each\nelement must be traversed to find the next element.\n\n`List α` is isomorphic to `Array α`, but they are useful for different things:\n* `List α` is easier for reasoning, and `Array α` is modeled as a wrapper around `List α`.\n* `List α` works well as a persistent data structure, when many copies of the tail are shared. When\n  the value is not shared, `Array α` will have better performance because it can do destructive\n  updates.\n</code>","140":"<code>Nat.zero_le (n : ℕ) : 0 ≤ n</code>","141":"<code>LeanW26.my_theorem : my_prop</code>","142":"<code>True : Prop</code><span class=\"sep\"></span><code class=\"docstring\">`True` is a proposition and has only an introduction rule, `True.intro : True`.\nIn other words, `True` is simply true, and has a canonical proof, `True.intro`\nFor more information: [Propositional Logic](https://lean-lang.org/theorem_proving_in_lean4/propositions_and_proofs.html#propositional-logic)\n</code>","143":"<code>False : Prop</code><span class=\"sep\"></span><code class=\"docstring\">`False` is the empty proposition. Thus, it has no introduction rules.\nIt represents a contradiction. `False` elimination rule, `False.rec`,\nexpresses the fact that anything follows from a contradiction.\nThis rule is sometimes called ex falso (short for ex falso sequitur quodlibet),\nor the principle of explosion.\nFor more information: [Propositional Logic](https://lean-lang.org/theorem_proving_in_lean4/propositions_and_proofs.html#propositional-logic)\n</code>","144":"<code>Int : Type</code><span class=\"sep\"></span><code class=\"docstring\">The integers.\n\nThis type is special-cased by the compiler and overridden with an efficient implementation. The\nruntime has a special representation for `Int` that stores “small” signed numbers directly, while\nlarger numbers use a fast arbitrary-precision arithmetic library (usually\n[GMP](https://gmplib.org/)). A “small number” is an integer that can be encoded with one fewer bits\nthan the platform's pointer size (i.e. 63 bits on 64-bit architectures and 31 bits on 32-bit\narchitectures).\n</code>","145":"<code>Rat : Type</code><span class=\"sep\"></span><code class=\"docstring\">Rational numbers, implemented as a pair of integers `num / den` such that the\ndenominator is positive and the numerator and denominator are coprime.\n</code>","146":"<code>Real : Type</code><span class=\"sep\"></span><code class=\"docstring\">The type `ℝ` of real numbers constructed as equivalence classes of Cauchy sequences of rational\nnumbers. </code>","147":"<code>Complex : Type</code><span class=\"sep\"></span><code class=\"docstring\">Complex numbers consist of two `Real`s: a real part `re` and an imaginary part `im`. </code>","148":"<code>Float : Type</code><span class=\"sep\"></span><code class=\"docstring\">64-bit floating-point numbers.\n\n`Float` corresponds to the IEEE 754 *binary64* format (`double` in C or `f64` in Rust).\nFloating-point numbers are a finite representation of a subset of the real numbers, extended with\nextra “sentinel” values that represent undefined and infinite results as well as separate positive\nand negative zeroes. Arithmetic on floating-point numbers approximates the corresponding operations\non the real numbers by rounding the results to numbers that are representable, propagating error and\ninfinite values.\n\nFloating-point numbers include [subnormal numbers](https://en.wikipedia.org/wiki/Subnormal_number).\nTheir special values are:\n * `NaN`, which denotes a class of “not a number” values that result from operations such as\n   dividing zero by zero, and\n * `Inf` and `-Inf`, which represent positive and infinities that result from dividing non-zero\n   values by zero.\n</code>","149":"<code>Float32 : Type</code><span class=\"sep\"></span><code class=\"docstring\">32-bit floating-point numbers.\n\n`Float32` corresponds to the IEEE 754 *binary32* format (`float` in C or `f32` in Rust).\nFloating-point numbers are a finite representation of a subset of the real numbers, extended with\nextra “sentinel” values that represent undefined and infinite results as well as separate positive\nand negative zeroes. Arithmetic on floating-point numbers approximates the corresponding operations\non the real numbers by rounding the results to numbers that are representable, propagating error and\ninfinite values.\n\nFloating-point numbers include [subnormal numbers](https://en.wikipedia.org/wiki/Subnormal_number).\nTheir special values are:\n * `NaN`, which denotes a class of “not a number” values that result from operations such as\n   dividing zero by zero, and\n * `Inf` and `-Inf`, which represent positive and infinities that result from dividing non-zero\n   values by zero.\n\n</code>","15":"<code>LeanW26.Universes.my_id.{u} (x : Type u) : Type u</code>","150":"<code>LeanW26.invert_rat (x : ℚ) : ℚ</code>","151":"<code>ℚ</code>","152":"<code>Rat.den (self : ℚ) : ℕ</code><span class=\"sep\"></span><code class=\"docstring\">The denominator of the rational number is a natural number. </code>","153":"<code>Rat.num (self : ℚ) : ℤ</code><span class=\"sep\"></span><code class=\"docstring\">The numerator of the rational number is an integer. </code>","154":"<code>LeanW26.invert_real (x : ℝ) : ℝ</code>","155":"<code>ℝ</code>","156":"<code>LeanW26.invert_invert : invert_real ∘ invert_real = id</code>","157":"<code>id.{u} {α : Sort u} (a : α) : α</code><span class=\"sep\"></span><code class=\"docstring\">The identity function. `id` takes an implicit argument `α : Sort u`\n(a type in any universe), and an argument `a : α`, and returns `a`.\n\nAlthough this may look like a useless function, one application of the identity\nfunction is to explicitly put a type on an expression. If `e` has type `T`,\nand `T'` is definitionally equal to `T`, then `@id T' e` typechecks, and Lean\nknows that this expression has type `T'` rather than `T`. This can make a\ndifference for typeclass inference, since `T` and `T'` may have different\ntypeclass instances on them. `show T' from e` is sugar for an `@id T' e`\nexpression.\n</code>","158":"<code>Function.comp.{u, v, w} {α : Sort u} {β : Sort v} {δ : Sort w} (f : β → δ) (g : α → β) : α → δ</code><span class=\"sep\"></span><code class=\"docstring\">Function composition, usually written with the infix operator `∘`. A new function is created from\ntwo existing functions, where one function's output is used as input to the other.\n\nExamples:\n * `Function.comp List.reverse (List.drop 2) [3, 2, 4, 1] = [1, 4]`\n * `(List.reverse ∘ List.drop 2) [3, 2, 4, 1] = [1, 4]`\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `∘` in identifiers is `comp`.</code>","159":"<code>Rat.ofInt (num : ℤ) : ℚ</code><span class=\"sep\"></span><code class=\"docstring\">Embedding of `Int` in the rational numbers. </code>","16":"<code>String : Type</code><span class=\"sep\"></span><code class=\"docstring\">A string is a sequence of Unicode scalar values.\n\nAt runtime, strings are represented by [dynamic arrays](https://en.wikipedia.org/wiki/Dynamic_array)\nof bytes using the UTF-8 encoding. Both the size in bytes (`String.utf8ByteSize`) and in characters\n(`String.length`) are cached and take constant time. Many operations on strings perform in-place\nmodifications when the reference to the string is unique.\n</code>","160":"<code>ℤ</code>","161":"<code>LeanW26.toRat (x : ℤ) : ℚ</code>","162":"<code>Char : Type</code><span class=\"sep\"></span><code class=\"docstring\">Characters are Unicode [scalar values](http://www.unicode.org/glossary/#unicode_scalar_value).\n</code>","163":"<code>Char.toNat (c : Char) : ℕ</code><span class=\"sep\"></span><code class=\"docstring\">The character's Unicode code point as a `Nat`.\n</code>","164":"<code>Char.mk (val : UInt32) (valid : val.isValidChar) : Char</code>","165":"<code>UInt32</code>","166":"<code>UInt32.isValidChar (n : UInt32) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">A `UInt32` denotes a valid Unicode code point if it is less than `0x110000` and it is also not a\nsurrogate code point (the range `0xd800` to `0xdfff` inclusive).\n</code>","167":"<code class=\"docstring\">`aesop &lt;clause&gt;*` tries to solve the current goal by applying a set of rules\nregistered with the `@[aesop]` attribute. See [its\nREADME](https://github.com/JLimperg/aesop#readme) for a tutorial and a\nreference.\n\nThe variant `aesop?` prints the proof it found as a `Try this` suggestion.\n\nClauses can be used to customise the behaviour of an Aesop call. Available\nclauses are:\n\n- `(add &lt;phase&gt; &lt;priority&gt; &lt;builder&gt; &lt;rule&gt;)` adds a rule. `&lt;phase&gt;` is\n  `unsafe`, `safe` or `norm`. `&lt;priority&gt;` is a percentage for unsafe rules and\n  an integer for safe and norm rules. `&lt;rule&gt;` is the name of a declaration or\n  local hypothesis. `&lt;builder&gt;` is the rule builder used to turn `&lt;rule&gt;` into\n  an Aesop rule. Example: `(add unsafe 50% apply Or.inl)`.\n- `(erase &lt;rule&gt;)` disables a globally registered Aesop rule. Example: `(erase\n  Aesop.BuiltinRules.assumption)`.\n- `(rule_sets := [&lt;ruleset&gt;,*])` enables or disables named sets of rules for\n  this Aesop call. Example: `(rule_sets := [-builtin, MyRuleSet])`.\n- `(config { &lt;opt&gt; := &lt;value&gt; })` adjusts Aesop's search options. See\n  `Aesop.Options`.\n- `(simp_config { &lt;opt&gt; := &lt;value&gt; })` adjusts options for Aesop's built-in\n  `simp` rule. The given options are directly passed to `simp`. For example,\n  `(simp_config := { zeta := false })` makes Aesop use\n  `simp (config := { zeta := false })`.\n</code>","168":"<code>Char.isLower (c : Char) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Returns `true` if the character is a lowercase ASCII letter.\n\nThe lowercase ASCII letters are the following: `abcdefghijklmnopqrstuvwxyz`.\n</code>","169":"<code>Char.toUpper (c : Char) : Char</code><span class=\"sep\"></span><code class=\"docstring\">Converts a lowercase ASCII letter to the corresponding uppercase letter. Letters outside the ASCII\nalphabet are returned unchanged.\n\nThe lowercase ASCII letters are the following: `abcdefghijklmnopqrstuvwxyz`.\n</code>","17":"<code class=\"docstring\">The universe level 1</code>","170":"<code><span class=\"literal string\">\"uw\"</span> : String</code>","171":"<code>String.ofList (data : List Char) : String</code><span class=\"sep\"></span><code class=\"docstring\">Creates a string that contains the characters in a list, in order.\n\nExamples:\n* `['L', '∃', '∀', 'N'].asString = \"L∃∀N\"`\n* `[].asString = \"\"`\n* `['a', 'a', 'a'].asString = \"aaa\"`\n</code>","172":"<code><span class=\"literal string\">\"u\"</span> : String</code>","173":"<code><span class=\"literal string\">\"w\"</span> : String</code>","174":"<code>List Char</code>","175":"<code>String.mk (data : List Char) : String</code>","176":"<code><span class=\"literal string\">\"UW\"</span> : String</code>","177":"<code>String.toUpper (s : String) : String</code><span class=\"sep\"></span><code class=\"docstring\">Replaces each character in `s` with the result of applying `Char.toUpper` to it.\n\n`Char.toUpper` has no effect on characters outside of the range `'a'`–`'z'`.\n\nExamples:\n* `\"orange\".toUpper = \"ORANGE\"`\n* `\"abc123\".toUpper = \"ABC123\"`\n</code>","178":"<code><span class=\"literal string\">\"uwece\"</span> : String</code>","179":"<code>LeanW26.f5 (L : List ℕ) : ℕ</code>","18":"<code class=\"docstring\">The maximum of two universes.</code>","180":"<code>List ℕ</code>","181":"<code>List.nil.{u} {α : Type u} : List α</code><span class=\"sep\"></span><code class=\"docstring\">The empty list, usually written `[]`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `[]` in identifiers is `nil`.</code>","182":"<code>List.cons.{u} {α : Type u} (head : α) (tail : List α) : List α</code><span class=\"sep\"></span><code class=\"docstring\">The list whose first element is `head`, where `tail` is the rest of the list.\nUsually written `head :: tail`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `::` in identifiers is `cons`.\n\n * The recommended spelling of `[a]` in identifiers is `singleton`.</code>","183":"<code>LeanW26.map (f : ℕ → ℕ) (L : List ℕ) : List ℕ</code>","184":"<code>LeanW26.map' (f : ℕ → ℕ) (L : List ℕ) : List ℕ</code>","185":"<code>LeanW26.map_poly {A B : Type} (f : A → B) (L : List A) : List B</code>","186":"<code>A → B</code>","187":"<code>List A</code>","188":"<code>LeanW26.map_poly_explicit (A B : Type) (f : A → B) (L : List A) : List B</code>","189":"<code>Vector.{u} (α : Type u) (n : ℕ) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">`Vector α n` is an `Array α` with size `n`. </code>","19":"<code class=\"docstring\">The universe parameter v</code>","190":"<code>Array.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">`Array α` is the type of [dynamic arrays](https://en.wikipedia.org/wiki/Dynamic_array) with elements\nfrom `α`. This type has special support in the runtime.\n\nArrays perform best when unshared. As long as there is never more than one reference to an array,\nall updates will be performed _destructively_. This results in performance comparable to mutable\narrays in imperative programming languages.\n\nAn array has a size and a capacity. The size is the number of elements present in the array, while\nthe capacity is the amount of memory currently allocated for elements. The size is accessible via\n`Array.size`, but the capacity is not observable from Lean code. `Array.emptyWithCapacity n` creates\nan array which is equal to `#[]`, but internally allocates an array of capacity `n`. When the size\nexceeds the capacity, allocation is required to grow the array.\n\nFrom the point of view of proofs, `Array α` is just a wrapper around `List α`.\n</code>","191":"<code>Set.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">A set is a collection of elements of some type `α`.\n\nAlthough `Set` is defined as `α → Prop`, this is an implementation detail which should not be\nrelied on. Instead, `setOf` and membership of a set (`∈`) should be used to convert between sets\nand predicates.\n</code>","192":"<code>Multiset.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">`Multiset α` is the quotient of `List α` by list permutation. The result\nis a type of finite sets with duplicates allowed. </code>","193":"<code>LeanW26.S1 : Set (Set Char)</code>","194":"<code>LeanW26.S2 : Set (List Char)</code>","195":"<code>LeanW26.S3 : List (Set Char)</code>","196":"<code>LeanW26.S4 : Array (Set Char)</code>","197":"<code>Group.{u} (G : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">A `Group` is a `Monoid` with an operation `⁻¹` satisfying `a⁻¹ * a = 1`.\n\nThere is also a division operation `/` such that `a / b = a * b⁻¹`,\nwith a default so that `a / b = a * b⁻¹` holds by definition.\n\nUse `Group.ofLeftAxioms` or `Group.ofRightAxioms` to define a group structure\non a type with the minimum proof obligations.\n</code>","198":"<code>Type u_1</code>","199":"<code>G</code>","2":"<code class=\"docstring\">A type universe. `Type ≡ Type 0`, `Type u ≡ Sort (u + 1)`. </code>","20":"<code>Type v</code>","200":"<code>LeanW26.insert (x : ℕ) : List ℕ → List ℕ</code>","201":"<code>LeanW26.insertionSort : List ℕ → List ℕ</code>","202":"<code>LeanW26.str_cmp (a b : String) : Bool</code>","203":"<code>String</code>","204":"<code>Decidable.decide (p : Prop) [h : Decidable p] : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Converts a decidable proposition into a `Bool`.\n\nIf `p : Prop` is decidable, then `decide p : Bool` is the Boolean value\nthat is `true` if `p` is true and `false` if `p` is false.\n</code>","205":"<code>2 * x &lt; 3 * y</code>","206":"<code>-4 * x + 2 * z &lt; 0</code>","207":"<code>12 * y - 4 * z &lt; 0</code>","208":"<code>LT.lt.{u} {α : Type u} [self : LT α] : α → α → Prop</code><span class=\"sep\"></span><code class=\"docstring\">The less-than relation: `x &lt; y` \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `&lt;` in identifiers is `lt`.</code>","209":"<code>HSub.hSub.{u, v, w} {α : Type u} {β : Type v} {γ : outParam (Type w)} [self : HSub α β γ] : α → β → γ</code><span class=\"sep\"></span><code class=\"docstring\">`a - b` computes the difference of `a` and `b`.\nThe meaning of this notation is type-dependent.\n* For natural numbers, this operator saturates at 0: `a - b = 0` when `a ≤ b`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `-` in identifiers is `sub` (when used as a binary operator).</code>","21":"<code>Prod.{u, v} (α : Type u) (β : Type v) : Type (max u v)</code><span class=\"sep\"></span><code class=\"docstring\">The product type, usually written `α × β`. Product types are also called pair or tuple types.\nElements of this type are pairs in which the first element is an `α` and the second element is a\n`β`.\n\nProducts nest to the right, so `(x, y, z) : α × β × γ` is equivalent to `(x, (y, z)) : α × (β × γ)`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `×` in identifiers is `Prod`.</code>","210":"<code class=\"docstring\">`linarith` attempts to find a contradiction between hypotheses that are linear (in)equalities.\nEquivalently, it can prove a linear inequality by assuming its negation and proving `False`.\n\nIn theory, `linarith` should prove any goal that is true in the theory of linear arithmetic over\nthe rationals. While there is some special handling for non-dense orders like `Nat` and `Int`,\nthis tactic is not complete for these theories and will not prove every true goal. It will solve\ngoals over arbitrary types that instantiate `CommRing`, `LinearOrder` and `IsStrictOrderedRing`.\n\nAn example:\n```lean\nexample (x y z : ℚ) (h1 : 2*x &lt; 3*y) (h2 : -4*x + 2*z &lt; 0)\n        (h3 : 12*y - 4* z &lt; 0) : False := by\n  linarith\n```\n\n`linarith` will use all appropriate hypotheses and the negation of the goal, if applicable.\nDisequality hypotheses require case splitting and are not normally considered\n(see the `splitNe` option below).\n\n`linarith [t1, t2, t3]` will additionally use proof terms `t1, t2, t3`.\n\n`linarith only [h1, h2, h3, t1, t2, t3]` will use only the goal (if relevant), local hypotheses\n`h1`, `h2`, `h3`, and proofs `t1`, `t2`, `t3`. It will ignore the rest of the local context.\n\n`linarith!` will use a stronger reducibility setting to try to identify atoms. For example,\n```lean\nexample (x : ℚ) : id x ≥ x := by\n  linarith\n```\nwill fail, because `linarith` will not identify `x` and `id x`. `linarith!` will.\nThis can sometimes be expensive.\n\n`linarith (config := { .. })` takes a config object with five\noptional arguments:\n* `discharger` specifies a tactic to be used for reducing an algebraic equation in the\n  proof stage. The default is `ring`. Other options include `simp` for basic\n  problems.\n* `transparency` controls how hard `linarith` will try to match atoms to each other. By default\n  it will only unfold `reducible` definitions.\n* If `splitHypotheses` is true, `linarith` will split conjunctions in the context into separate\n  hypotheses.\n* If `splitNe` is `true`, `linarith` will case split on disequality hypotheses.\n  For a given `x ≠ y` hypothesis, `linarith` is run with both `x &lt; y` and `x &gt; y`,\n  and so this runs linarith exponentially many times with respect to the number of\n  disequality hypotheses. (`false` by default.)\n* If `exfalso` is `false`, `linarith` will fail when the goal is neither an inequality nor `False`.\n  (`true` by default.)\n* If `minimize` is `false`, `linarith?` will report all hypotheses appearing in its initial\n  proof without attempting to drop redundancies. (`true` by default.)\n* `restrict_type` (not yet implemented in mathlib4)\n  will only use hypotheses that are inequalities over `tp`. This is useful\n  if you have e.g. both integer- and rational-valued inequalities in the local context, which can\n  sometimes confuse the tactic.\n\nA variant, `nlinarith`, does some basic preprocessing to handle some nonlinear goals.\n\nThe option `set_option trace.linarith true` will trace certain intermediate stages of the `linarith`\nroutine.\n</code>","211":"<code><span class=\"literal string\">\"1\"</span> : String</code>","212":"<code><span class=\"literal string\">\"hello world\"</span> : String</code>","213":"<code><span class=\"literal string\">\"hello\"</span> : String</code>","214":"<code>String.append (s : String) (t : String) : String</code><span class=\"sep\"></span><code class=\"docstring\">Appends two strings. Usually accessed via the `++` operator.\n\nThe internal implementation will perform destructive updates if the string is not shared.\n\nExamples:\n* `\"abc\".append \"def\" = \"abcdef\"`\n* `\"abc\" ++ \"def\" = \"abcdef\"`\n* `\"\" ++ \"\" = \"\"`\n</code>","215":"<code><span class=\"literal string\">\" world\"</span> : String</code>","216":"<code><span class=\"literal string\">\"everything is ok\"</span> : String</code>","217":"<code><span class=\"literal string\">\"the universe has a problem\"</span> : String</code>","218":"<code>Nat.Prime (p : ℕ) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">`Nat.Prime p` means that `p` is a prime number, that is, a natural number\nat least 2 whose only divisors are `p` and `1`.\nThe theorem `Nat.prime_def` witnesses this description of a prime number. </code>","219":"<code>my_amazing_result (p : Prop) : p → p</code>","22":"<code class=\"docstring\">The impredicative maximum of two universes:\n\n * `imax u 0 = 0`\n * `imax u (v+1) = max u (v+1)`</code>","220":"<code>a_less_amazing_result : True → True</code>","221":"<code>q → r</code>","222":"<code>And (a b : Prop) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">`And a b`, or `a ∧ b`, is the conjunction of propositions. It can be\nconstructed and destructed like a pair: if `ha : a` and `hb : b` then\n`⟨ha, hb⟩ : a ∧ b`, and if `h : a ∧ b` then `h.left : a` and `h.right : b`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `∧` in identifiers is `and`.\n\n * The recommended spelling of `/\\` in identifiers is `and` (prefer `∧` over `/\\`).</code>","223":"<code class=\"docstring\">The `sorry` tactic is a temporary placeholder for an incomplete tactic proof,\nclosing the main goal using `exact sorry`.\n\nThis is intended for stubbing-out incomplete parts of a proof while still having a syntactically correct proof skeleton.\nLean will give a warning whenever a proof uses `sorry`, so you aren't likely to miss it,\nbut you can double check if a theorem depends on `sorry` by looking for `sorryAx` in the output\nof the `#print axioms my_thm` command, the axiom used by the implementation of `sorry`.\n</code>","224":"<code class=\"docstring\">Introduces one or more hypotheses, optionally naming and/or pattern-matching them.\nFor each hypothesis to be introduced, the remaining main goal's target type must\nbe a `let` or function type.\n\n* `intro` by itself introduces one anonymous hypothesis, which can be accessed\n  by e.g. `assumption`. It is equivalent to `intro _`.\n* `intro x y` introduces two hypotheses and names them. Individual hypotheses\n  can be anonymized via `_`, given a type ascription, or matched against a pattern:\n  ```lean\n  -- ... ⊢ α × β → ...\n  intro (a, b)\n  -- ..., a : α, b : β ⊢ ...\n  ```\n* `intro rfl` is short for `intro h; subst h`, if `h` is an equality where the left-hand or right-hand side\n  is a variable.\n* Alternatively, `intro` can be combined with pattern matching much like `fun`:\n  ```lean\n  intro\n  | n + 1, 0 =&gt; tac\n  | ...\n  ```\n</code>","225":"<code class=\"docstring\">The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.\nThe definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.\n\n* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.\n* `have h := e` uses the type of `e` for `t`.\n* `have : t := e` and `have := e` use `this` for the name of the hypothesis.\n* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,\n  where `_` stands for the tactics that follow this one.\n  It is convenient for types that have only one applicable constructor.\n  For example, given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the\n  hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.\n* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,\n  which adds the equation `h : e = pat` to the local context.\n\nThe tactic supports all the same syntax variants and options as the `have` term.\n\n## Properties and relations\n\n* It is not possible to unfold a variable introduced using `have`, since the definition's value is forgotten.\n  The `let` tactic introduces definitions that can be unfolded.\n* The `have h : t := e` is like doing `let h : t := e; clear_value h`.\n* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.\n* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,\n  which may be important for performance reasons.\n    Consider using the equivalent `let +nondep` to indicate the intent.\n\n</code>","226":"<code>q</code>","227":"<code>r</code>","228":"<code class=\"docstring\">`exact e` closes the main goal if its target type matches that of `e`.\n</code>","229":"<code>remove_zeros (L : List ℕ) : List ℕ</code>","23":"<code>LeanW26.Universes.MyProd.{u} (α β : Type u) : Type (u + 1)</code>","230":"<code>MyNat : Type</code>","231":"<code>MyNat.zero : MyNat</code>","232":"<code>MyNat.succ : MyNat → MyNat</code>","233":"<code class=\"docstring\">Makes names from other namespaces visible without writing the namespace prefix.\n\nNames that are made available with `open` are visible within the current `section` or `namespace`\nblock. This makes referring to (type) definitions and theorems easier, but note that it can also\nmake [scoped instances], notations, and attributes from a different namespace available.\n\nThe `open` command can be used in a few different ways:\n\n* `open Some.Namespace.Path1 Some.Namespace.Path2` makes all non-protected names in\n  `Some.Namespace.Path1` and `Some.Namespace.Path2` available without the prefix, so that\n  `Some.Namespace.Path1.x` and `Some.Namespace.Path2.y` can be referred to by writing only `x` and\n  `y`.\n\n* `open Some.Namespace.Path hiding def1 def2` opens all non-protected names in `Some.Namespace.Path`\n  except `def1` and `def2`.\n\n* `open Some.Namespace.Path (def1 def2)` only makes `Some.Namespace.Path.def1` and\n  `Some.Namespace.Path.def2` available without the full prefix, so `Some.Namespace.Path.def3` would\n  be unaffected.\n\n  This works even if `def1` and `def2` are `protected`.\n\n* `open Some.Namespace.Path renaming def1 → def1', def2 → def2'` same as `open Some.Namespace.Path\n  (def1 def2)` but `def1`/`def2`'s names are changed to `def1'`/`def2'`.\n\n  This works even if `def1` and `def2` are `protected`.\n\n* `open scoped Some.Namespace.Path1 Some.Namespace.Path2` **only** opens [scoped instances],\n  notations, and attributes from `Namespace1` and `Namespace2`; it does **not** make any other name\n  available.\n\n* `open &lt;any of the open shapes above&gt; in` makes the names `open`-ed visible only in the next\n  command or expression.\n\n[scoped instance]: https://lean-lang.org/theorem_proving_in_lean4/type_classes.html#scoped-instances\n(Scoped instances in Theorem Proving in Lean)\n\n\n## Examples\n\n```lean\n/-- SKI combinators https://en.wikipedia.org/wiki/SKI_combinator_calculus -/\nnamespace Combinator.Calculus\n  def I (a : α) : α := a\n  def K (a : α) : β → α := fun _ =&gt; a\n  def S (x : α → β → γ) (y : α → β) (z : α) : γ := x z (y z)\nend Combinator.Calculus\n\nsection\n  -- open everything under `Combinator.Calculus`, *i.e.* `I`, `K` and `S`,\n  -- until the section ends\n  open Combinator.Calculus\n\n  theorem SKx_eq_K : S K x = I := rfl\nend\n\n-- open everything under `Combinator.Calculus` only for the next command (the next `theorem`, here)\nopen Combinator.Calculus in\ntheorem SKx_eq_K' : S K x = I := rfl\n\nsection\n  -- open only `S` and `K` under `Combinator.Calculus`\n  open Combinator.Calculus (S K)\n\n  theorem SKxy_eq_y : S K x y = y := rfl\n\n  -- `I` is not in scope, we have to use its full path\n  theorem SKxy_eq_Iy : S K x y = Combinator.Calculus.I y := rfl\nend\n\nsection\n  open Combinator.Calculus\n    renaming\n      I → identity,\n      K → konstant\n\n  #check identity\n  #check konstant\nend\n\nsection\n  open Combinator.Calculus\n    hiding S\n\n  #check I\n  #check K\nend\n\nsection\n  namespace Demo\n    inductive MyType\n    | val\n\n    namespace N1\n      scoped infix:68 \" ≋ \" =&gt; BEq.beq\n\n      scoped instance : BEq MyType where\n        beq _ _ := true\n\n      def Alias := MyType\n    end N1\n  end Demo\n\n  -- bring `≋` and the instance in scope, but not `Alias`\n  open scoped Demo.N1\n\n  #check Demo.MyType.val == Demo.MyType.val\n  #check Demo.MyType.val ≋ Demo.MyType.val\n  -- #check Alias -- unknown identifier 'Alias'\nend\n```\n</code>","234":"<code>MyComplex : Type</code>","235":"<code>MyComplex.mk : ℝ → ℝ → MyComplex</code>","236":"<code>MyComplex.re (x : MyComplex) : ℝ</code>","237":"<code>MyComplex</code>","238":"<code>MyComplex.im (x : MyComplex) : ℝ</code>","239":"<code>MyComplex.abs (x : MyComplex) : ℝ</code>","24":"<code>LeanW26.Universes.MyPropProd (α β : Prop) : Prop</code>","240":"<code>Real.sqrt (x : ℝ) : ℝ</code><span class=\"sep\"></span><code class=\"docstring\">The square root of a real number. This returns 0 for negative inputs.\n\nThis has notation `√x`. Note that `√x⁻¹` is parsed as `√(x⁻¹)`. </code>","241":"<code>TriBool : Type</code>","242":"<code>TriBool.T : TriBool</code>","243":"<code>TriBool.F : TriBool</code>","244":"<code>TriBool.U : TriBool</code>","245":"<code>_root_.and (A B : TriBool) : TriBool</code>","246":"<code>TriBool</code>","247":"<code>BTree (A : Type) : Type</code>","248":"<code>BTree.leaf {A : Type} : A → BTree A</code>","249":"<code>BTree.node {A : Type} : A → BTree A → BTree A → BTree A</code>","25":"<code>Prop</code>","250":"<code>my_tree : BTree ℕ</code>","251":"<code>to_list {A : Type} (T : BTree A) : List A</code>","252":"<code>BTree A</code>","253":"<code>to_str {A : Type} [sa : ToString A] (T : BTree A) : String</code>","254":"<code>ToString A</code>","255":"<code>ToString.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">Types that can be converted into a string for display.\n\nThere is no expectation that the resulting string can be parsed back to the original data (see\n`Repr` for a similar class with this expectation).\n</code>","256":"<code>ToString.toString.{u} {α : Type u} [self : ToString α] : α → String</code><span class=\"sep\"></span><code class=\"docstring\">Converts a value into a string. </code>","257":"<code><span class=\"literal string\">\"(\"</span> : String</code>","258":"<code><span class=\"literal string\">\" \"</span> : String</code>","259":"<code><span class=\"literal string\">\")\"</span> : String</code>","26":"<code class=\"docstring\">`end` closes a `section` or `namespace` scope. If the scope is named `&lt;id&gt;`, it has to be closed\nwith `end &lt;id&gt;`. The `end` command is optional at the end of a file.\n</code>","260":"<code>Repr.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">The standard way of turning values of some type into `Format`.\n\nWhen rendered this `Format` should be as close as possible to something that can be parsed as the\ninput value.\n</code>","261":"<code>BTree A → ℕ → Std.Format</code><span class=\"sep\"></span><code class=\"docstring\">Turn a value of type `α` into a `Format` at a given precedence. The precedence value can be used\nto avoid parentheses if they are not necessary.\n</code>","262":"<code>bt_map {A B : Type} (f : A → B) (T : BTree A) : BTree B</code>","263":"<code>Komplex : Type</code>","264":"<code>Komplex.re (self : Komplex) : ℝ</code>","265":"<code>Komplex.im (self : Komplex) : ℝ</code>","266":"<code>conj (x : Komplex) : Komplex</code>","267":"<code>Komplex</code>","268":"<code>ℝ</code>","269":"<code>add (x y : Komplex) : Komplex</code>","27":"<code>LeanW26.Simple.A : Type 1</code>","270":"<code>Komplex.mk (re im : ℝ) : Komplex</code>","271":"<code>negate (x : Komplex) : Komplex</code>","272":"<code>negate1 (x : Komplex) : Komplex</code>","273":"<code>negate2 (x : Komplex) : Komplex</code>","274":"<code>negate3 (x : Komplex) : Komplex</code>","275":"<code>negate4 (x : Komplex) : Komplex</code>","276":"<code>MyProd (A B : Type) : Type</code>","277":"<code>MyProd.fst {A B : Type} (self : MyProd A B) : A</code>","278":"<code>MyProd.snd {A B : Type} (self : MyProd A B) : B</code>","279":"<code>p : MyProd ℚ String</code>","28":"<code>LeanW26.Simple.B : Type 1</code>","280":"<code>MyProd.mk {A B : Type} (fst : A) (snd : B) : MyProd A B</code>","281":"<code><span class=\"literal string\">\"zero\"</span> : String</code>","282":"<code>q : ℚ × String</code>","283":"<code>Prod.mk.{u, v} {α : Type u} {β : Type v} (fst : α) (snd : β) : α × β</code><span class=\"sep\"></span><code class=\"docstring\">Constructs a pair. This is usually written `(x, y)` instead of `Prod.mk x y`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `(a, b)` in identifiers is `mk`.</code>","284":"<code><span class=\"literal string\">\"one\"</span> : String</code>","285":"<code>MySum (A B : Type) : Type</code>","286":"<code>MySum.inl {A B : Type} : A → MySum A B</code>","287":"<code>MySum.inr {A B : Type} : B → MySum A B</code>","288":"<code>s1 : MySum ℚ String</code>","289":"<code>s2 : MySum ℚ String</code>","29":"<code class=\"docstring\">Declares one or more typed variables, or modifies whether already-declared variables are\n  implicit.\n\nIntroduces variables that can be used in definitions within the same `namespace` or `section` block.\nWhen a definition mentions a variable, Lean will add it as an argument of the definition. This is\nuseful in particular when writing many definitions that have parameters in common (see below for an\nexample).\n\nVariable declarations have the same flexibility as regular function parameters. In particular they\ncan be [explicit, implicit][binder docs], or [instance implicit][tpil classes] (in which case they\ncan be anonymous). This can be changed, for instance one can turn explicit variable `x` into an\nimplicit one with `variable {x}`. Note that currently, you should avoid changing how variables are\nbound and declare new variables at the same time; see [issue 2789] for more on this topic.\n\nIn *theorem bodies* (i.e. proofs), variables are not included based on usage in order to ensure that\nchanges to the proof cannot change the statement of the overall theorem. Instead, variables are only\navailable to the proof if they have been mentioned in the theorem header or in an `include` command\nor are instance implicit and depend only on such variables.\n\nSee [*Variables and Sections* from Theorem Proving in Lean][tpil vars] for a more detailed\ndiscussion.\n\n[tpil vars]:\nhttps://lean-lang.org/theorem_proving_in_lean4/dependent_type_theory.html#variables-and-sections\n(Variables and Sections on Theorem Proving in Lean) [tpil classes]:\nhttps://lean-lang.org/theorem_proving_in_lean4/type_classes.html (Type classes on Theorem Proving in\nLean) [binder docs]:\nhttps://leanprover-community.github.io/mathlib4_docs/Lean/Expr.html#Lean.BinderInfo (Documentation\nfor the BinderInfo type) [issue 2789]: https://github.com/leanprover/lean4/issues/2789 (Issue 2789\non github)\n\n## Examples\n\n```lean\nsection\n  variable\n    {α : Type u}      -- implicit\n    (a : α)           -- explicit\n    [instBEq : BEq α] -- instance implicit, named\n    [Hashable α]      -- instance implicit, anonymous\n\n  def isEqual (b : α) : Bool :=\n    a == b\n\n  #check isEqual\n  -- isEqual.{u} {α : Type u} (a : α) [instBEq : BEq α] (b : α) : Bool\n\n  variable\n    {a} -- `a` is implicit now\n\n  def eqComm {b : α} := a == b ↔ b == a\n\n  #check eqComm\n  -- eqComm.{u} {α : Type u} {a : α} [instBEq : BEq α] {b : α} : Prop\nend\n```\n\nThe following shows a typical use of `variable` to factor out definition arguments:\n\n```lean\nvariable (Src : Type)\n\nstructure Logger where\n  trace : List (Src × String)\n#check Logger\n-- Logger (Src : Type) : Type\n\nnamespace Logger\n  -- switch `Src : Type` to be implicit until the `end Logger`\n  variable {Src}\n\n  def empty : Logger Src where\n    trace := []\n  #check empty\n  -- Logger.empty {Src : Type} : Logger Src\n\n  variable (log : Logger Src)\n\n  def len :=\n    log.trace.length\n  #check len\n  -- Logger.len {Src : Type} (log : Logger Src) : Nat\n\n  variable (src : Src) [BEq Src]\n\n  -- at this point all of `log`, `src`, `Src` and the `BEq` instance can all become arguments\n\n  def filterSrc :=\n    log.trace.filterMap\n      fun (src', str') =&gt; if src' == src then some str' else none\n  #check filterSrc\n  -- Logger.filterSrc {Src : Type} (log : Logger Src) (src : Src) [inst✝ : BEq Src] : List String\n\n  def lenSrc :=\n    log.filterSrc src |&gt;.length\n  #check lenSrc\n  -- Logger.lenSrc {Src : Type} (log : Logger Src) (src : Src) [inst✝ : BEq Src] : Nat\nend Logger\n```\n\nThe following example demonstrates availability of variables in proofs:\n```lean\nvariable\n  {α : Type}    -- available in the proof as indirectly mentioned through `a`\n  [ToString α]  -- available in the proof as `α` is included\n  (a : α)       -- available in the proof as mentioned in the header\n  {β : Type}    -- not available in the proof\n  [ToString β]  -- not available in the proof\n\ntheorem ex : a = a := rfl\n```\nAfter elaboration of the proof, the following warning will be generated to highlight the unused\nhypothesis:\n```\nincluded section variable '[ToString α]' is not used in 'ex', consider excluding it\n```\nIn such cases, the offending variable declaration should be moved down or into a section so that\nonly theorems that do depend on it follow it until the end of the section.\n</code>","290":"<code>swap (s : MySum ℚ String) : MySum String ℚ</code>","291":"<code>MySum ℚ String</code>","292":"<code>s : ℚ ⊕ String</code>","293":"<code>Sum.inl.{u, v} {α : Type u} {β : Type v} (val : α) : α ⊕ β</code><span class=\"sep\"></span><code class=\"docstring\">Left injection into the sum type `α ⊕ β`. </code>","294":"<code>MyOption (A : Type) : Type</code>","295":"<code>MyOption.none {A : Type} : MyOption A</code>","296":"<code>MyOption.some {A : Type} : A → MyOption A</code>","297":"<code>first {A : Type} (L : List A) : MyOption A</code>","298":"<code>my_func (L : List ℕ) : List ℕ</code>","299":"<code>MyOption ℕ</code>","3":"<code class=\"docstring\">The universe level 0</code>","30":"<code>A</code>","300":"<code>MyNat.add (x y : MyNat) : MyNat</code>","301":"<code>MyNat</code>","302":"<code class=\"docstring\">`infix:prec \"op\" =&gt; f` is equivalent to `notation:prec x:prec1 \"op\" y:prec1 =&gt; f x y`, where `prec1 := prec + 1`.\n</code>","303":"<code><span class=\"literal string\">\" + \"</span> : String</code>","304":"<code>Temp.Dyadic : Type</code>","305":"<code>Temp.Dyadic.zero : Dyadic</code>","306":"<code>Temp.Dyadic.add_one : Dyadic → Dyadic</code>","307":"<code>Temp.Dyadic.half : Dyadic → Dyadic</code>","31":"<code>A → A</code>","32":"<code>LeanW26.Simple.inc₁ (x : ℕ) : ℕ</code>","33":"<code>ℕ</code>","34":"<code>LeanW26.Simple.inc₂ (x : ℕ) : ℕ</code>","35":"<code class=\"docstring\">`#eval e` evaluates the expression `e` by compiling and evaluating it.\n\n* The command attempts to use `ToExpr`, `Repr`, or `ToString` instances to print the result.\n* If `e` is a monadic value of type `m ty`, then the command tries to adapt the monad `m`\n  to one of the monads that `#eval` supports, which include `IO`, `CoreM`, `MetaM`, `TermElabM`, and `CommandElabM`.\n  Users can define `MonadEval` instances to extend the list of supported monads.\n\nThe `#eval` command gracefully degrades in capability depending on what is imported.\nImporting the `Lean.Elab.Command` module provides full capabilities.\n\nDue to unsoundness, `#eval` refuses to evaluate expressions that depend on `sorry`, even indirectly,\nsince the presence of `sorry` can lead to runtime instability and crashes.\nThis check can be overridden with the `#eval! e` command.\n\nOptions:\n* If `eval.pp` is true (default: true) then tries to use `ToExpr` instances to make use of the\n  usual pretty printer. Otherwise, only tries using `Repr` and `ToString` instances.\n* If `eval.type` is true (default: false) then pretty prints the type of the evaluated value.\n* If `eval.derive.repr` is true (default: true) then attempts to auto-derive a `Repr` instance\n  when there is no other way to print the result.\n\nSee also: `#reduce e` for evaluation by term reduction.\n</code>","36":"<code>Type</code>","37":"<code>Type → Type</code>","38":"<code>LeanW26.Simple.c (x : Type) : Type</code>","39":"<code class=\"docstring\">`#reduce &lt;expression&gt;` reduces the expression `&lt;expression&gt;` to its normal form. This\ninvolves applying reduction rules until no further reduction is possible.\n\nBy default, proofs and types within the expression are not reduced. Use modifiers\n`(proofs := true)`  and `(types := true)` to reduce them.\nRecall that propositions are types in Lean.\n\n**Warning:** This can be a computationally expensive operation,\nespecially for complex expressions.\n\nConsider using `#eval &lt;expression&gt;` for simple evaluation/execution\nof expressions.\n</code>","4":"<code class=\"docstring\">The universe level 12</code>","40":"<code>LeanW26.Simple.h₁ (y : A) : A</code>","41":"<code>LeanW26.Simple.h₂ (g : A → A) (y : A) : A</code>","42":"<code>LeanW26.Simple.α : Type 1</code>","43":"<code>LeanW26.Simple.c₀ (f : α → α) (x : α) : α</code>","44":"<code>α → α</code>","45":"<code>α</code>","46":"<code>LeanW26.Simple.c₁ (f : α → α) (x : α) : α</code>","47":"<code>LeanW26.Simple.c₂ (f : α → α) (x : α) : α</code>","48":"<code>LeanW26.Simple.c₃ (f : α → α) (x : α) : α</code>","49":"<code>LeanW26.Simple.N : Type 1</code>","5":"<code class=\"docstring\">The universe level 100</code>","50":"<code>LeanW26.Simple.succ (m : N) (f : α → α) (x : α) : α</code>","51":"<code>N</code>","52":"<code>LeanW26.Simple.add (m n : N) (f : α → α) (x : α) : α</code>","53":"<code>LeanW26.Simple.mul (m n : N) (f : α → α) (x : α) : α</code>","54":"<code>LeanW26.Simple.ifzero (m n p : N) (f : α → α) (x : α) : α</code>","55":"<code>LeanW26.Simple.one_plus_one_is_two : add c₁ c₁ = c₂</code>","56":"<code>rfl.{u} {α : Sort u} {a : α} : a = a</code><span class=\"sep\"></span><code class=\"docstring\">`rfl : a = a` is the unique constructor of the equality type. This is the\nsame as `Eq.refl` except that it takes `a` implicitly instead of explicitly.\n\nThis is a more powerful theorem than it may appear at first, because although\nthe statement of the theorem is `a = a`, Lean will allow anything that is\ndefinitionally equal to that type. So, for instance, `2 + 2 = 4` is proven in\nLean by `rfl`, because both sides are the same up to definitional equality.\n</code>","57":"<code>?m.1</code>","58":"<code>?m.3 x</code>","59":"<code>?m.3 x✝</code>","6":"<code class=\"docstring\">Declares one or more universe variables.\n\n`universe u v`\n\n`Prop`, `Type`, `Type u` and `Sort u` are types that classify other types, also known as\n*universes*. In `Type u` and `Sort u`, the variable `u` stands for the universe's *level*, and a\nuniverse at level `u` can only classify universes that are at levels lower than `u`. For more\ndetails on type universes, please refer to [the relevant chapter of Theorem Proving in Lean][tpil\nuniverses].\n\nJust as type arguments allow polymorphic definitions to be used at many different types, universe\nparameters, represented by universe variables, allow a definition to be used at any required level.\nWhile Lean mostly handles universe levels automatically, declaring them explicitly can provide more\ncontrol when writing signatures. The `universe` keyword allows the declared universe variables to be\nused in a collection of definitions, and Lean will ensure that these definitions use them\nconsistently.\n\n[tpil universes]: https://lean-lang.org/theorem_proving_in_lean4/dependent_type_theory.html#types-as-objects\n(Type universes on Theorem Proving in Lean)\n\n```lean\n/- Explicit type-universe parameter. -/\ndef id₁.{u} (α : Type u) (a : α) := a\n\n/- Implicit type-universe parameter, equivalent to `id₁`.\n  Requires option `autoImplicit true`, which is the default. -/\ndef id₂ (α : Type u) (a : α) := a\n\n/- Explicit standalone universe variable declaration, equivalent to `id₁` and `id₂`. -/\nuniverse u\ndef id₃ (α : Type u) (a : α) := a\n```\n\nOn a more technical note, using a universe variable only in the right-hand side of a definition\ncauses an error if the universe has not been declared previously.\n\n```lean\ndef L₁.{u} := List (Type u)\n\n-- def L₂ := List (Type u) -- error: `unknown universe level 'u'`\n\nuniverse u\ndef L₃ := List (Type u)\n```\n\n## Examples\n\n```lean\nuniverse u v w\n\nstructure Pair (α : Type u) (β : Type v) : Type (max u v) where\n  a : α\n  b : β\n\n#check Pair.{v, w}\n-- Pair : Type v → Type w → Type (max v w)\n```\n</code>","60":"<code>?m.5 g</code>","61":"<code>p</code>","62":"<code>p → q</code>","63":"<code>LeanW26.NonSimpleTypes.id1.{u} (α : Type u) : α → α</code>","64":"<code>x✝</code>","65":"<code>LeanW26.NonSimpleTypes.id2.{u} {α : Type u} : α → α</code>","66":"<code>α✝</code>","67":"<code>LeanW26.NonSimpleTypes.id3.{u} {α : Type u} (x : α) : α</code>","68":"<code>LeanW26.NonSimpleTypes.id4.{u} (α : Type u) : α → α</code>","69":"<code>LeanW26.NonSimpleTypes.id5.{u_1} (α : Sort u_1) : α → α</code>","7":"<code>LeanW26.Universes.f1.{u} (x : Type u) : Type u</code>","70":"<code>Sort u_1</code>","71":"<code class=\"docstring\">In Lean, every concrete type other than the universes\nand every type constructor other than dependent arrows\nis an instance of a general family of type constructions known as inductive types.\nIt is remarkable that it is possible to construct a substantial edifice of mathematics\nbased on nothing more than the type universes, dependent arrow types, and inductive types;\neverything else follows from those.\nIntuitively, an inductive type is built up from a specified list of constructors.\nFor example, `List α` is the list of elements of type `α`, and is defined as follows:\n```\ninductive List (α : Type u) where\n| nil\n| cons (head : α) (tail : List α)\n```\nA list of elements of type `α` is either the empty list, `nil`,\nor an element `head : α` followed by a list `tail : List α`.\nSee [Inductive types](https://lean-lang.org/theorem_proving_in_lean4/inductive_types.html)\nfor more information.\n</code>","72":"<code>LeanW26.NonSimpleTypes.MyList {α : Type} : Type</code>","73":"<code>LeanW26.NonSimpleTypes.MyList.nil {α : Type} : MyList</code>","74":"<code>LeanW26.NonSimpleTypes.MyList.cons {α : Type} : α → MyList → MyList</code>","75":"<code>LeanW26.NonSimpleTypes.Vec.{u} (α : Type u) : ℕ → Type u</code>","76":"<code>LeanW26.NonSimpleTypes.Vec.nil.{u} {α : Type u} : Vec α 0</code>","77":"<code>LeanW26.NonSimpleTypes.Vec.cons.{u} {α : Type u} {n : ℕ} : α → Vec α n → Vec α (n + 1)</code>","78":"<code>LeanW26.NonSimpleTypes.Vec.add.{u} {α : Type u} [Add α] {n : ℕ} (x y : Vec α n) : Vec α n</code>","79":"<code>Add.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">The homogeneous version of `HAdd`: `a + b : α` where `a b : α`. </code>","8":"<code>Type u</code>","80":"<code>Vec α n</code>","81":"<code class=\"docstring\">Pattern matching. `match e, ... with | p, ... =&gt; f | ...` matches each given\nterm `e` against each pattern `p` of a match alternative. When all patterns\nof an alternative match, the `match` term evaluates to the value of the\ncorresponding right-hand side `f` with the pattern variables bound to the\nrespective matched values.\nIf used as `match h : e, ... with | p, ... =&gt; f | ...`, `h : e = p` is available\nwithin `f`.\n\nWhen not constructing a proof, `match` does not automatically substitute variables\nmatched on in dependent variables' types. Use `match (generalizing := true) ...` to\nenforce this.\n\nSyntax quotations can also be used in a pattern match.\nThis matches a `Syntax` value against quotations, pattern variables, or `_`.\n\nQuoted identifiers only match identical identifiers - custom matching such as by the preresolved\nnames only should be done explicitly.\n\n`Syntax.atom`s are ignored during matching by default except when part of a built-in literal.\nFor users introducing new atoms, we recommend wrapping them in dedicated syntax kinds if they\nshould participate in matching.\nFor example, in\n```lean\nsyntax \"c\" (\"foo\" &lt;|&gt; \"bar\") ...\n```\n`foo` and `bar` are indistinguishable during matching, but in\n```lean\nsyntax foo := \"foo\"\nsyntax \"c\" (foo &lt;|&gt; \"bar\") ...\n```\nthey are not.\n</code>","82":"<code>Vec α n✝</code>","83":"<code>LeanW26.NonSimpleTypes.chooseType : Bool → Type</code>","84":"<code>Bool : Type</code><span class=\"sep\"></span><code class=\"docstring\">The Boolean values, `true` and `false`.\n\nLogically speaking, this is equivalent to `Prop` (the type of propositions). The distinction is\npublic important for programming: both propositions and their proofs are erased in the code generator,\nwhile `Bool` corresponds to the Boolean type in most programming languages and carries precisely one\nbit of run-time information.\n</code>","85":"<code>Bool.true : Bool</code><span class=\"sep\"></span><code class=\"docstring\">The Boolean value `true`, not to be confused with the proposition `True`. </code>","86":"<code>Bool.false : Bool</code><span class=\"sep\"></span><code class=\"docstring\">The Boolean value `false`, not to be confused with the proposition `False`. </code>","87":"<code>Sigma.mk.{u, v} {α : Type u} {β : α → Type v} (fst : α) (snd : β fst) : Sigma β</code><span class=\"sep\"></span><code class=\"docstring\">Constructs a dependent pair.\n\nUsing this constructor in a context in which the type is not known usually requires a type\nascription to determine `β`. This is because the desired relationship between the two values can't\ngenerally be determined automatically.\n</code>","88":"<code>LeanW26.NonSimpleTypes.Vec.default (n : ℕ) : (n : ℕ) × Vec ℕ n</code>","89":"<code class=\"docstring\">`let` is used to declare a local definition. Example:\n```\nlet x := 1\nlet y := x + 1\nx + y\n```\nSince functions are first class citizens in Lean, you can use `let` to declare\nlocal functions too.\n```\nlet double := fun x =&gt; 2*x\ndouble (double 3)\n```\nFor recursive definitions, you should use `let rec`.\nYou can also perform pattern matching using `let`. For example,\nassume `p` has type `Nat × Nat`, then you can write\n```\nlet (x, y) := p\nx + y\n```\n\nThe *anaphoric let* `let := v` defines a variable called `this`.\n</code>","9":"<code class=\"docstring\">The universe parameter u</code>","90":"<code>(n : ℕ) × Vec ℕ n</code>","91":"<code>Sigma.fst.{u, v} {α : Type u} {β : α → Type v} (self : Sigma β) : α</code><span class=\"sep\"></span><code class=\"docstring\">The first component of a dependent pair.\n</code>","92":"<code>Sigma.snd.{u, v} {α : Type u} {β : α → Type v} (self : Sigma β) : β self.fst</code><span class=\"sep\"></span><code class=\"docstring\">The second component of a dependent pair. Its type depends on the first component.\n</code>","93":"<code>LeanW26.LambdaCalculus.f1 (x : ℕ) : ℕ</code>","94":"<code>LeanW26.LambdaCalculus.g1 (x y : ℕ) : ℕ</code>","95":"<code>LeanW26.LambdaCalculus.f2 (x : ℕ) : ℕ</code>","96":"<code>LeanW26.LambdaCalculus.g2 (x y : ℕ) : ℕ</code>","97":"<code>LeanW26.LambdaCalculus.f3 : ℕ → ℕ</code>","98":"<code>LeanW26.LambdaCalculus.g3 : ℕ → ℕ → ℕ</code>","99":"<code>LeanW26.f1 (x : ℕ) : ℕ</code>"}